{"version":3,"file":"urbex.min.cjs","sources":["../../lib/utils.ts","../../lib/core/constants.ts","../../lib/core/parsers/base-url-parser.ts","../../lib/core/parsers/url-parser.ts","../../lib/environment.ts","../../lib/core/error.ts","../../lib/core/api/resolve-request.ts","../../lib/core/api/http.ts","../../lib/core/api/xhr.ts","../../lib/core/pipelines.ts","../../lib/core/headers.ts","../../lib/debug.ts","../../lib/core/api/request-api.ts","../../lib/core/api/conclude.ts","../../lib/core/transformers.ts","../../lib/core/request-config.ts","../../lib/core/urbex.ts","../../lib/urbex.ts"],"sourcesContent":["import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isNumber(value: unknown): value is number {\r\n    return typeof value === \"number\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(\r\n    defaultOptions: P,\r\n    options: T,\r\n    strict: boolean = false\r\n): P & T {\r\n    if (strict) {\r\n        const filteredOptions = keys(options).reduce((acc, key) => {\r\n            if (options[key]) {\r\n                acc[key] = options[key];\r\n            }\r\n\r\n            return acc;\r\n        }, {} as T);\r\n\r\n        return Object.assign({}, defaultOptions, filteredOptions);\r\n    } else {\r\n        return Object.assign({}, defaultOptions, options);\r\n    }\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combineStrings(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[], value = null): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = value;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import type { InternalConfiguration, URLComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { ParsedURLComponent, PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { createEmptyScheme } from \"../utils\";\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const URL_COMPONENT_KEYS: (keyof URLComponent)[] = [\r\n    \"href\",\r\n    \"origin\",\r\n    \"protocol\",\r\n    \"username\",\r\n    \"password\",\r\n    \"hostname\",\r\n    \"port\",\r\n    \"pathname\",\r\n    \"search\",\r\n    \"searchParams\",\r\n    \"hash\"\r\n];\r\n\r\nexport const DEFAULT_URL_COMPONENT = createEmptyScheme<ParsedURLComponent>(URL_COMPONENT_KEYS, \"\");\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: null,\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\n\r\nimport {\r\n    merge,\r\n    isString,\r\n    isNumber,\r\n    isEmpty,\r\n    isArray,\r\n    isObject,\r\n    createEmptyScheme,\r\n    lowercase,\r\n    combineStrings,\r\n    ensureTrailingToken,\r\n    ensureLeadingToken,\r\n    forEach\r\n} from \"../../utils\";\r\nimport { URL_COMPONENT_KEYS } from \"../constants\";\r\n\r\ninterface ParamsConversionOutput {\r\n    /**\r\n     * Stringified output of the search parameters.\r\n     */\r\n    search: string;\r\n    /**\r\n     * As a URLSearchParams object.\r\n     */\r\n    searchParams: URLSearchParams;\r\n}\r\n\r\nconst DEFAULT_PROTOCOL = \"http\";\r\n\r\nconst PARSE_URL =\r\n    /^(?:([^:\\/?#]+):)?(?:[\\/\\/]+((?:([^@\\/\\n]+)@)?((?:[0-9]{1,3}\\.){3}[0-9]{1,3}|\\[[0-9a-f:]+\\]|[^#:\\/?\\n]+)(?::(\\d*))?))?(?:[\\/]*([^?#]*))(?:[\\?]*([^#]*))?(?:[\\#]*(.*))?/i;\r\n\r\nconst IPV4_REGEX = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\r\nconst IPV6_REGEX = /^(\\[[0-9a-f:]+\\])$/i;\r\nconst AUTH_REGEX = /^([^:]+)(?:\\:([^:].+))?/;\r\nconst PORT_LOWER_LIMIT = 0;\r\nconst PORT_UPPER_LIMIT = 65535;\r\n\r\nfunction removeEncodedWhitespace(input: string): string {\r\n    return input.replace(/%20/g, \"\");\r\n}\r\n\r\nfunction normalizeIPv4(input: string): string {\r\n    const matches = IPV4_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        const numbers = matches.slice(1).map((num) => parseInt(num, 10));\r\n\r\n        if (numbers.every((num) => num <= 255)) {\r\n            return numbers.join(\".\");\r\n        }\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv4 address.\");\r\n}\r\n\r\nfunction normalizeIPv6(input: string): string {\r\n    const matches = IPV6_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        return matches[1];\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv6 address.\");\r\n}\r\n\r\nfunction formatPort(port: Port): string {\r\n    if (!port) {\r\n        return \"\";\r\n    }\r\n\r\n    if (isNumber(port) || !port.startsWith(\":\")) {\r\n        return `:${port}`;\r\n    } else {\r\n        return port;\r\n    }\r\n}\r\n\r\nexport function mergeAuth(username: string, password: string): string {\r\n    if (!username && password) {\r\n        throw new Error(\"Cannot set password without username.\");\r\n    }\r\n\r\n    if (!username) {\r\n        return \"\";\r\n    }\r\n\r\n    if (!password) {\r\n        return username;\r\n    }\r\n\r\n    return combineStrings(\":\", username, password);\r\n}\r\n\r\nexport function buildProtocol(protocol: string, hasHostname: boolean): string {\r\n    if (hasHostname || protocol === \"http\" || protocol === \"https\") {\r\n        return ensureTrailingToken(\"://\", protocol);\r\n    }\r\n\r\n    return ensureTrailingToken(\":\", protocol);\r\n}\r\n\r\nexport function extractScheme(input: string): string {\r\n    return input.replace(/:\\/\\/$/, \"\").replace(/:$/, \"\");\r\n}\r\n\r\nexport function convertSearchParamsToString(search: CustomSearchParams): ParamsConversionOutput {\r\n    if (!search || (!isString(search) && !isObject(search) && !isArray(search))) {\r\n        return {\r\n            search: \"\",\r\n            searchParams: null\r\n        };\r\n    }\r\n\r\n    if (isString(search)) {\r\n        return {\r\n            search: ensureLeadingToken(\"?\", removeEncodedWhitespace(search)),\r\n            searchParams: new URLSearchParams(search)\r\n        };\r\n    }\r\n\r\n    const searchParams = new URLSearchParams();\r\n\r\n    forEach(search, (key, value) => {\r\n        if (value) {\r\n            if (isArray(value)) {\r\n                const entry = value;\r\n                searchParams.append(entry[0] as string, entry[1] as string);\r\n            } else if (isObject(search)) {\r\n                searchParams.append(key, value);\r\n            }\r\n        }\r\n    });\r\n\r\n    return {\r\n        search: ensureLeadingToken(\"?\", searchParams.toString()),\r\n        searchParams: searchParams\r\n    };\r\n}\r\n\r\nexport class BaseURLParser {\r\n    protected $component: EnforceComponent;\r\n\r\n    constructor(input: string | SerializeComponent) {\r\n        if (input && !isString(input) && !isObject(input)) {\r\n            throw new TypeError(\"Invalid input. Must be a string or an object.\");\r\n        }\r\n\r\n        this.$component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        this.$component.searchParams = new URLSearchParams();\r\n\r\n        if (isString(input) && input) {\r\n            this.$component = this.parse(input);\r\n            return;\r\n        }\r\n\r\n        if (isObject(input) && !isEmpty(input)) {\r\n            if (input.href) {\r\n                this.$component = this.parse(input.href);\r\n            } else {\r\n                this.serialize(input);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    protected sync(\r\n        value: string,\r\n        replace: string,\r\n        syncType: \"all\" | \"href\" | \"origin\" = \"all\"\r\n    ): void {\r\n        const href = this.$component.href;\r\n        const origin = this.$component.origin;\r\n\r\n        if (value) {\r\n            if (syncType === \"all\" || syncType === \"href\") {\r\n                this.$component.href = href.replace(value, replace);\r\n            }\r\n\r\n            if (syncType === \"all\" || syncType === \"origin\") {\r\n                this.$component.origin = origin.replace(value, replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected syncAuth(origin: string, username: string, password: string): void {\r\n        if (!username) {\r\n            throw new Error(\"Cannot set password without username.\");\r\n        }\r\n\r\n        let [protocol, host] = origin.split(\"://\");\r\n\r\n        protocol = buildProtocol(protocol, !!host);\r\n\r\n        const authString = combineStrings(\"\", mergeAuth(username, password), \"@\");\r\n\r\n        this.$component.href = combineStrings(\"\", protocol, authString, host);\r\n    }\r\n\r\n    protected match(input: string): string[] {\r\n        return PARSE_URL.exec(input);\r\n    }\r\n\r\n    protected parseProtocol(input: string): string {\r\n        if (!input) {\r\n            const protocol = this.$component.protocol;\r\n            this.$component.protocol = protocol || DEFAULT_PROTOCOL;\r\n            return;\r\n        }\r\n\r\n        input = extractScheme(input);\r\n\r\n        const protocol = lowercase(removeEncodedWhitespace(input));\r\n        this.$component.protocol = protocol;\r\n    }\r\n\r\n    protected parseAuth(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const auth = AUTH_REGEX.exec(input);\r\n\r\n        if (auth && auth.length) {\r\n            const username = auth[1];\r\n            const password = auth[2];\r\n\r\n            if (!username) {\r\n                throw new Error(\"Expected username in auth.\");\r\n            }\r\n\r\n            this.$component.username = username;\r\n            this.$component.password = password || \"\";\r\n        } else {\r\n            throw new Error(\"Invalid auth format. Expected <username>:<password>\");\r\n        }\r\n    }\r\n\r\n    protected parseHostname(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const isIPv4 = IPV4_REGEX.test(input);\r\n\r\n        if (isIPv4) {\r\n            input = normalizeIPv4(input);\r\n        } else {\r\n            const isIPv6 = IPV6_REGEX.test(input);\r\n            if (isIPv6) {\r\n                input = normalizeIPv6(input);\r\n            } else {\r\n                input = lowercase(input);\r\n            }\r\n        }\r\n\r\n        this.$component.hostname = removeEncodedWhitespace(input);\r\n    }\r\n\r\n    protected parsePort(port: Port): void {\r\n        if (!port) {\r\n            this.$component.port = \"\";\r\n            return;\r\n        }\r\n\r\n        const parsePort = isNumber(port) ? port : parseInt(port, 10);\r\n\r\n        if (isNaN(parsePort) || parsePort < PORT_LOWER_LIMIT || parsePort > PORT_UPPER_LIMIT) {\r\n            throw new Error(\"Port must be between 0 and 65535.\");\r\n        }\r\n\r\n        this.$component.port = parsePort;\r\n    }\r\n\r\n    protected parseOrigin(origin: string): void {\r\n        const protocol = buildProtocol(this.$component.protocol, !!this.$component.hostname);\r\n\r\n        if (!origin || !this.$component.hostname) {\r\n            this.$component.origin = \"null\";\r\n        } else {\r\n            this.$component.origin = ensureLeadingToken(protocol, origin);\r\n        }\r\n\r\n        const authString = mergeAuth(this.$component.username, this.$component.password);\r\n\r\n        if (authString && this.$component.origin.includes(authString)) {\r\n            const replaceAuth = combineStrings(\"\", authString, \"@\");\r\n            this.$component.origin = this.$component.origin.replace(replaceAuth, \"\");\r\n        }\r\n    }\r\n\r\n    protected parsePathname(pathname: string): void {\r\n        if (!pathname) {\r\n            return;\r\n        }\r\n\r\n        if (this.$component.hostname) {\r\n            this.$component.pathname = ensureLeadingToken(\"/\", pathname);\r\n        } else {\r\n            this.$component.pathname = pathname;\r\n        }\r\n    }\r\n\r\n    protected parseParams(params: CustomSearchParams): void {\r\n        if (!params) {\r\n            return;\r\n        }\r\n\r\n        const search = convertSearchParamsToString(params);\r\n\r\n        if (search) {\r\n            this.$component.search = ensureLeadingToken(\"?\", search.search);\r\n            this.$component.searchParams = new URLSearchParams(search.searchParams);\r\n        }\r\n    }\r\n\r\n    protected parseHash(hash: string): void {\r\n        if (!hash) {\r\n            return;\r\n        }\r\n\r\n        this.$component.hash = ensureLeadingToken(\"#\", hash);\r\n    }\r\n\r\n    /**\r\n     * Parses a URL string and returns a URL object.\r\n     */\r\n    public parse(input: string, overwrite: boolean = true): EnforceComponent {\r\n        if (!isString(input) || isEmpty(input)) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        component.searchParams = new URLSearchParams();\r\n\r\n        if (overwrite) {\r\n            this.$component = component;\r\n        } else {\r\n            this.$component = merge(component, this.$component);\r\n        }\r\n\r\n        input = input.trim();\r\n        input = input.replace(/\\s/g, \"%20\");\r\n        input = input.replace(/\\\\/g, \"/\");\r\n\r\n        const matches = this.match(input);\r\n\r\n        if (matches === null || matches.length === 0) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const [href, protocol, origin, auth, hostname, port, pathname, query, hash] = matches;\r\n\r\n        this.parseProtocol(protocol);\r\n        this.parseAuth(auth);\r\n        this.parseHostname(hostname);\r\n        this.parsePort(port);\r\n        this.parsePathname(pathname);\r\n        this.parseParams(query);\r\n        this.parseHash(hash);\r\n        this.parseOrigin(origin);\r\n\r\n        this.$component.href = href;\r\n\r\n        return this.$component;\r\n    }\r\n\r\n    /**\r\n     * Serializes a URL object into a URL string.\r\n     */\r\n    public serialize(_component: SerializeComponent, overwrite: boolean = true): string {\r\n        const baseComponent = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        const component = merge(baseComponent, _component);\r\n\r\n        const tokens: string[] = [];\r\n\r\n        const authString = mergeAuth(component.username, component.password);\r\n\r\n        if (component.origin) {\r\n            const [_, protocol, origin, auth, host, port] = this.match(component.origin);\r\n\r\n            tokens.push(buildProtocol(protocol, !!host));\r\n\r\n            if (authString && !component.origin.includes(authString)) {\r\n                // this is a safe check to ensure the user didn't provide a username/password\r\n                // in the origin string. If they did, we'll remove it and use the one provided\r\n                // in the username/password properties.\r\n\r\n                const newOrigin = origin.replace(`${auth}@`, \"\");\r\n\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n                tokens.push(newOrigin);\r\n            } else {\r\n                if (auth) {\r\n                    tokens.push(auth);\r\n                    tokens.push(\"@\");\r\n                }\r\n\r\n                tokens.push(host);\r\n\r\n                if (port) {\r\n                    tokens.push(formatPort(port));\r\n                }\r\n            }\r\n        } else {\r\n            if (!component.protocol) {\r\n                throw new Error(\"Expected a protocol when serializing a URL.\");\r\n            }\r\n\r\n            if (component.protocol === \"http\" || component.protocol === \"https\") {\r\n                if (!component.hostname) {\r\n                    throw new Error(\r\n                        \"Expected a hostname when serializing a URL with an HTTP protocol.\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            tokens.push(buildProtocol(component.protocol, !!component.hostname));\r\n\r\n            if (authString) {\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n            }\r\n\r\n            if (component.hostname) {\r\n                tokens.push(component.hostname);\r\n            }\r\n\r\n            tokens.push(formatPort(component.port));\r\n        }\r\n\r\n        tokens.push(ensureLeadingToken(\"/\", component.pathname));\r\n\r\n        const searchParams = component.search || component.searchParams || \"\";\r\n\r\n        if (searchParams) {\r\n            if (searchParams instanceof URLSearchParams) {\r\n                const search = searchParams.toString();\r\n\r\n                if (search) {\r\n                    tokens.push(ensureLeadingToken(\"?\", search));\r\n                }\r\n            } else {\r\n                const { search } = convertSearchParamsToString(searchParams.toString());\r\n                tokens.push(ensureLeadingToken(\"?\", search));\r\n            }\r\n        }\r\n\r\n        if (component.hash) {\r\n            tokens.push(ensureLeadingToken(\"#\", component.hash));\r\n        }\r\n\r\n        const url = tokens.filter((token) => token && token !== \"/\").join(\"\");\r\n\r\n        try {\r\n            const parsed = this.parse(url, overwrite);\r\n            return parsed.href;\r\n        } catch (error) {\r\n            throw new Error(\"Attempted to serialize an invalid URL.\");\r\n        }\r\n    }\r\n}\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\nimport { combineStrings, ensureLeadingToken } from \"../../utils\";\r\n\r\nimport {\r\n    BaseURLParser,\r\n    mergeAuth,\r\n    extractScheme,\r\n    buildProtocol,\r\n    convertSearchParamsToString\r\n} from \"./base-url-parser\";\r\nimport { merge } from \"../../utils\";\r\n\r\n// build this as a seperate package\r\n\r\n/**\r\n * The internal URL parser that is responsible for parsing and serializing\r\n * URLs and their components.\r\n */\r\nexport class URLParser extends BaseURLParser {\r\n    constructor(input?: string | SerializeComponent) {\r\n        super(input);\r\n    }\r\n\r\n    /**\r\n     * Parse the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static parse(input: string): URLParser {\r\n        return new this(input);\r\n    }\r\n\r\n    /**\r\n     * Serialize the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static serialize(component: SerializeComponent): string {\r\n        return new this().serialize(component);\r\n    }\r\n\r\n    /**\r\n     * Set a component object without enforcing the component to serialize\r\n     * or parse. Merges the component with the existing component.\r\n     *\r\n     * This does not validate the component.\r\n     */\r\n    public set(component: SerializeComponent): this {\r\n        this.$component = merge(this.$component, component);\r\n\r\n        if (component.searchParams instanceof URLSearchParams) {\r\n            this.$component.search = component.searchParams.toString();\r\n            this.$component.searchParams = component.searchParams;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public get href(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public set href(value: string) {\r\n        this.parse(value);\r\n    }\r\n\r\n    public get origin(): string {\r\n        return this.$component.origin;\r\n    }\r\n\r\n    public set origin(value: string) {\r\n        const [href, protocol, origin, auth, hostname, port] = this.match(value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        const component = merge<EnforceComponent, SerializeComponent>(this.$component, {\r\n            href: \"\",\r\n            origin: combineStrings(\"\", buildProtocol(protocol, !!hostname), origin)\r\n        });\r\n\r\n        this.serialize(component);\r\n    }\r\n\r\n    public get protocol(): string {\r\n        return this.$component.protocol;\r\n    }\r\n\r\n    public set protocol(value: string) {\r\n        if (value === this.protocol) {\r\n            return;\r\n        }\r\n\r\n        const existing = buildProtocol(this.protocol, !!this.hostname);\r\n        const incoming = buildProtocol(extractScheme(value), !value.includes(\"data\"));\r\n\r\n        this.parseProtocol(value);\r\n\r\n        this.sync(existing, incoming);\r\n    }\r\n\r\n    public get username(): string {\r\n        return this.$component.username;\r\n    }\r\n\r\n    public set username(value: string) {\r\n        const existing = this.username;\r\n\r\n        if (value === this.username) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(value, this.password);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get password(): string {\r\n        return this.$component.password;\r\n    }\r\n\r\n    public set password(value: string) {\r\n        const existing = this.password;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(this.username, value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get hostname(): string {\r\n        return this.$component.hostname;\r\n    }\r\n\r\n    public set hostname(value: string) {\r\n        const existing = this.hostname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHostname(value);\r\n        this.sync(existing, this.hostname);\r\n    }\r\n\r\n    public get port(): Port {\r\n        return this.$component.port;\r\n    }\r\n\r\n    public set port(value: Port) {\r\n        const existing = this.port.toString();\r\n\r\n        if (value.toString() === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePort(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.port.toString());\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const originWithPort = combineStrings(\":\", origin, this.port.toString());\r\n\r\n            this.sync(origin, originWithPort);\r\n        }\r\n    }\r\n\r\n    public get pathname(): string {\r\n        return this.$component.pathname;\r\n    }\r\n\r\n    public set pathname(value: string) {\r\n        const existing = this.pathname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePathname(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.pathname);\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const pathname = ensureLeadingToken(\"/\", this.pathname);\r\n            const originwithPathname = combineStrings(\"\", origin, pathname);\r\n\r\n            this.sync(origin, originwithPathname, \"href\");\r\n        }\r\n    }\r\n\r\n    public get search(): string {\r\n        return convertSearchParamsToString(this.$component.search).search;\r\n    }\r\n\r\n    public get searchParams(): URLSearchParams {\r\n        return this.$component.searchParams;\r\n    }\r\n\r\n    public get hash(): string {\r\n        return this.$component.hash;\r\n    }\r\n\r\n    public set hash(value: string) {\r\n        const existing = this.hash;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHash(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.hash, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const hash = ensureLeadingToken(\"#\", this.hash);\r\n            const originwithHash = combineStrings(\"\", origin, hash);\r\n\r\n            this.sync(origin, originwithHash, \"href\");\r\n        }\r\n    }\r\n\r\n    public setSearchParams(value: CustomSearchParams | URLSearchParams, merge: boolean = false) {\r\n        const existing = this.search;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        if (value instanceof URLSearchParams) {\r\n            value = value.toString();\r\n        }\r\n\r\n        this.parseParams(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.search, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const search = ensureLeadingToken(\"?\", this.search);\r\n            const originwithSearch = combineStrings(\"\", origin, search);\r\n\r\n            this.sync(origin, originwithSearch, \"href\");\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public toJSON(): EnforceComponent {\r\n        return this.$component;\r\n    }\r\n}\r\n","import { URLParser } from \"./core/parsers/url-parser\";\r\n\r\nexport type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n\r\n    public getEnvironmentComponent(): URLParser {\r\n        if (this.isBrowser) {\r\n            return URLParser.parse(window.location.href);\r\n        } else {\r\n            const port = process.env.PORT || \"3000\";\r\n            const parsed = URLParser.parse(`http://localhost:${port}`);\r\n\r\n            return parsed;\r\n        }\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nfunction replaceCallStackWithName(stack: string, name: string): string {\r\n    return stack.replace(/^Error/, name);\r\n}\r\n\r\n/**\r\n * Base error class for Urbex that extends the native Error class.\r\n */\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n    message: string = \"An error occurred while executing a request.\";\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n        error.name = this.name;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createFromError<T extends typeof UrbexError>(this: T, error: Error): InstanceType<T> {\r\n        if (!(error instanceof Error)) {\r\n            error = new Error(error);\r\n        }\r\n\r\n        const instance = new this(error.message);\r\n\r\n        if (error.stack) {\r\n            instance.stack = replaceCallStackWithName(error.stack, this.name);\r\n        }\r\n\r\n        instance.name = this.name;\r\n\r\n        if (UrbexError.isInstance(error)) {\r\n            instance.name = error.name;\r\n        }\r\n\r\n        return instance as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\n/**\r\n * A TimeoutError is thrown when the request takes longer than the specified timeout.\r\n */\r\nexport class TimeoutError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = message || \"The request timed out.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A NetworkError is thrown when the request fails to reach the server.\r\n */\r\nexport class NetworkError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = message || \"Failed to request the resource.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A PipelineError is thrown when executing a pipeline fails.\r\n */\r\nexport class PipelineError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"PipelineError\";\r\n        this.message = message || \"An error occurred while executing a pipeline.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { ResolvableEntity } from \"../../types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: ResolvableEntity\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n\r\n    try {\r\n        const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n        if (canResolve) {\r\n            return resolve(entity);\r\n        }\r\n\r\n        const errorInstance: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n\r\n        errorInstance.status = status;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.request = this.request;\r\n\r\n        if (environment.isNode) {\r\n            errorInstance.message = entity.response.statusMessage;\r\n        } else {\r\n            errorInstance.message = entity.response.statusText;\r\n        }\r\n\r\n        if (!errorInstance.message) {\r\n            errorInstance.message = `Request failed with status code ${status}`;\r\n        }\r\n\r\n        return reject(errorInstance);\r\n    } catch (error) {\r\n        const errorInstance: UrbexError = UrbexError.createFromError.call(UrbexError, error);\r\n\r\n        errorInstance.message = error.message;\r\n        errorInstance.config = this.config;\r\n        errorInstance.request = this.request;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.status = status;\r\n\r\n        return reject(errorInstance);\r\n    }\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combineStrings, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combineStrings(\"\", config.url.pathname, config.url.search),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                options.port = config.url.port;\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError, error);\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","/* istanbul ignore file */\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(\r\n                    UrbexError,\r\n                    new Error(\"Request was aborted\")\r\n                );\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError, new Error(\"Network Error\"));\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject, forEach, isString } from \"../utils\";\r\nimport { PipelineError } from \"../core/error\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            if (!(pipeline instanceof PipelineExecutor)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid pipeline to be passed to the `process` method.\"\r\n                );\r\n            }\r\n\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public async execute(config: Parameters<T>): Promise<ReturnType<T>> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\n\r\nconst DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nconst DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { isUndefined } from \"../../utils\";\r\nimport { DEFAULT_CLIENT_OPTIONS } from \"../constants\";\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = config;\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.createFromError.call(UrbexError, error);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\nimport { UrbexError, PipelineError } from \"../error\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        try {\r\n            await PipelineExecutor.process<InternalConfiguration, RequestExecutor>(\r\n                config,\r\n                config.pipelines.request\r\n            );\r\n        } catch (error) {\r\n            const errorInstance: UrbexError = UrbexError.createFromError.call(PipelineError, error);\r\n            errorInstance.config = config;\r\n            return Promise.reject(errorInstance);\r\n        }\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        const incomingResult: UrbexResponse = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache.\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            try {\r\n                await PipelineExecutor.process<UrbexResponse, ResponseExecutor>(\r\n                    incomingResult,\r\n                    config.pipelines.response\r\n                );\r\n            } catch (error) {\r\n                const errorInstance: UrbexError = UrbexError.createFromError.call(\r\n                    PipelineError,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = incomingResult.request;\r\n                errorInstance.response = incomingResult.response;\r\n                errorInstance.status = incomingResult.status;\r\n                return Promise.reject(errorInstance);\r\n            }\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { InternalConfiguration, UrbexConfig, UrbexURL } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport { URLParser } from \"./parsers/url-parser\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { METHODS } from \"./constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URL_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction isPathname(pathname: string): boolean {\r\n    if (!pathname.startsWith(\"//\") && pathname.startsWith(\"/\")) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction manageURLComponent(this: URLParser, component: UrbexURL, allowEndpoints: boolean): void {\r\n    if (isString(component)) {\r\n        const hasPathname = isPathname(component);\r\n\r\n        if (hasPathname) {\r\n            if (allowEndpoints) {\r\n                this.pathname = component;\r\n            } else {\r\n                throw new Error(\r\n                    \"A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n                );\r\n            }\r\n        } else {\r\n            this.parse(component);\r\n        }\r\n    } else {\r\n        // the serializer always uses the origin if passed\r\n        // however this conflicts if the configuration method\r\n        // is called multiple times attempting to change\r\n        // components of the URL. By default, the origin will always\r\n        // be present since it was parsed previously and will fail to\r\n        // adjust the other components.\r\n\r\n        // to fix this, if the origin is not passed, we will\r\n        // set it to an empty string so that the serializer\r\n        // will not use it.\r\n\r\n        if (component.origin === undefined) {\r\n            component.origin = \"\";\r\n        }\r\n\r\n        component.href ? this.parse(component.href) : this.set(component).serialize(this.toJSON());\r\n    }\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        /* istanbul ignore if */\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const envComponent = environment.getEnvironmentComponent();\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const options = deepClone(DEFAULT_CLIENT_OPTIONS);\r\n\r\n        const configuration = deepMerge(options, {\r\n            url: envComponent,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: environment.getEnvironmentComponent(),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        if (isEmpty(config)) {\r\n            return {};\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const configuration = clone(config);\r\n\r\n        const clonedUrl = clone(currentConfig.url.toJSON());\r\n        const parser = new URLParser();\r\n\r\n        parser.set(clonedUrl);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const url = configuration.url;\r\n\r\n            if (!isString(url) && !isObject(url)) {\r\n                throw new Error(\"The url property must be a string or an object.\");\r\n            }\r\n\r\n            manageURLComponent.call(parser, url, allowEndpoints);\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(configuration.timeout?.toString(), 10);\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(configuration.maxContentLength?.toString(), 10);\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n\r\n        configuration.headers = null;\r\n        configuration.url = null;\r\n\r\n        return merge<UrbexConfig, Partial<InternalConfiguration>>(configuration, {\r\n            headers: headers,\r\n            url: parser\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config) || isEmpty(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n        const incomingComponent = config.url?.toJSON() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers.get(), incomingHeaders);\r\n        const mergedComponent = merge(currentConfig.url.toJSON(), incomingComponent);\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n        const componentObject = new URLParser();\r\n\r\n        componentObject.set(mergedComponent);\r\n\r\n        return merge<InternalConfiguration, Partial<InternalConfiguration>>(merged, {\r\n            headers: headersObject,\r\n            url: componentObject\r\n        });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    public get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    public get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            /* istanbul ignore next */\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n// export * from \"./core/headers\";\r\nexport * from \"./core/parsers/url-parser\";\r\nexport * from \"./core/error\";\r\n\r\nexport default urbex;\r\n"],"names":["hasOwnProperty","obj","prop","call","isUndefined","value","isArray","Array","isObject","isString","isFunction","isNumber","isEmpty","length","Object","keys","uppercase","String","toUpperCase","lowercase","toLowerCase","clone","slice","assign","deepClone","map","constructor","key","merge","defaultOptions","options","strict","filteredOptions","reduce","acc","deepMerge","objects","concat","forEach","fn","index","ensureLeadingToken","token","argumentIsNotProvided","startsWith","ensureTrailingToken","endsWith","combineStrings","delimiter","strings","filter","string","join","createEmptyScheme","split","object","nestedKeys","nestedObject","REQUEST_BODY_METHODS","URL_COMPONENT_KEYS","DEFAULT_PIPELINE_EXECUTORS","request","response","DEFAULT_CLIENT_OPTIONS","url","timeout","method","headers","data","cache","pipelines","maxContentLength","Infinity","responseType","responseEncoding","resolveStatus","config","status","DEFAULT_URBEX_RESPONSE","METHODS","PARSE_URL","IPV4_REGEX","IPV6_REGEX","AUTH_REGEX","removeEncodedWhitespace","input","replace","formatPort","port","mergeAuth","username","password","Error","buildProtocol","protocol","hasHostname","extractScheme","convertSearchParamsToString","search","searchParams","URLSearchParams","entry","append","toString","BaseURLParser","TypeError","this","$component","parse","href","serialize","sync","syncType","origin","syncAuth","host","authString","match","exec","parseProtocol","parseAuth","auth","parseHostname","test","matches","numbers","num","parseInt","every","normalizeIPv4","normalizeIPv6","hostname","parsePort","isNaN","parseOrigin","includes","replaceAuth","parsePathname","pathname","parseParams","params","parseHash","hash","overwrite","component","trim","query","_component","tokens","_","push","newOrigin","error","URLParser","super","static","set","existing","incoming","originWithPort","originwithPathname","originwithHash","setSearchParams","originwithSearch","toJSON","environment","_context","detectContext","window","document","process","versions","node","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","getEnvironmentComponent","location","PORT","UrbexError","message","name","instance","create","stack","isInstance","TimeoutError","NetworkError","PipelineError","resolveRequest","resolve","reject","entity","statusCode","errorInstance","createErrorInstance","statusMessage","statusText","createFromError","NodeRequest","getAgentFromProtocol","https","http","handleDataProtocolRequest","Promise","async","_resolve","_reject","agent","has","path","get","onData","onError","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","chunks","chunk","timeoutError","end","undefined","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","event","listener","open","delete","setRequestHeader","bind","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","$executor","executor","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","removeNewLines","stringReplacer","parseHeaderKey","format","word","parsedWord","charAt","formatHeaderKey","parseHeaderValue","JSON","stringify","UrbexHeaders","$headers","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","console","normalizedHeaders","normalize","merged","headerKey","clear","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$cache","CacheClock","autoStart","debug","$api","configuration","concludeRequest","startTime","Date","now","timestamp","toISOString","clonedResponse","result","incomingResult","hit","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","v","pulled","stored","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","manageURLComponent","allowEndpoints","RequestConfig","setup","createConfigurationObject","envComponent","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$maxCon","currentConfig","clonedUrl","parser","construct","$config","_config$headers","_config$url","incomingHeaders","incomingComponent","mergedHeaders","mergedComponent","headersObject","componentObject","reset","createMethodConfig","uri","UrbexClient","configure","stopCache","isRunning","stop","start","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","prototype","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}