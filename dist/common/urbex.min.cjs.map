{"version":3,"file":"urbex.min.cjs","sources":["../../lib/environment.ts","../../lib/core/error.ts","../../lib/core/api/resolve-request.ts","../../lib/utils.ts","../../lib/core/api/http.ts","../../lib/core/api/xhr.ts","../../lib/core/pipelines.ts","../../lib/core/constants.ts","../../lib/core/headers.ts","../../lib/debug.ts","../../lib/core/api/request-api.ts","../../lib/core/api/conclude.ts","../../lib/core/transformers.ts","../../lib/constants.ts","../../lib/core/url.ts","../../lib/core/request-config.ts","../../lib/core/urbex.ts","../../lib/urbex.ts"],"sourcesContent":["export type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\nexport class TimeoutError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = \"The request timed out.\";\r\n    }\r\n\r\n    public set timeout(timeout: number) {\r\n        this.message = `Timeout of ${timeout}ms exceeded`;\r\n    }\r\n}\r\n\r\nexport class NetworkError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = \"Failed to request the resource.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: any\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n    const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n    if (canResolve) {\r\n        return resolve(entity);\r\n    }\r\n\r\n    const error: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n    const errorMessage = `Request failed with status code ${status}`;\r\n\r\n    error.message = environment.isNode\r\n        ? entity.response.statusMessage\r\n        : entity.response.statusText ?? errorMessage;\r\n    error.request = this.request;\r\n    error.status = status;\r\n    error.response = entity.response;\r\n\r\n    return reject(error);\r\n}\r\n","import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(defaultOptions: P, options: T): P & T {\r\n    return Object.assign({}, defaultOptions, options);\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combinedStringss(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[]): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = null;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { Socket } from \"net\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi, DispatchedAPIRequest } from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combinedStringss, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            if (config.url.params && !isString(config.url.params)) {\r\n                config.url.params = config.url.params.toString();\r\n            } else {\r\n                config.url.params = \"\";\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combinedStringss(\"\", config.url.endpoint, config.url.params),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                const port = parseInt(config.url.port.toString());\r\n\r\n                if (!isNaN(port)) {\r\n                    options.port = port;\r\n                }\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError);\r\n                errorInstance.message = error.message;\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(UrbexError);\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError);\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject } from \"../utils\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult) || argumentIsNotProvided(pipelineResult)) {\r\n                throw new Error(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public execute(config: Parameters<T>): ReturnType<T> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { InternalConfiguration, URIComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { environment } from \"../environment\";\r\nimport { merge, createEmptyScheme } from \"../utils\";\r\n\r\nexport const DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nexport const DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const DEFAULT_URI_COMPONENT = createEmptyScheme<URIComponent>([\r\n    \"endpoint\",\r\n    \"hostname\",\r\n    \"href\",\r\n    \"origin\",\r\n    \"params\",\r\n    \"port\",\r\n    \"protocol\",\r\n    \"urlMount\"\r\n]);\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"http\",\r\n        urlMount: \"/api\"\r\n    }),\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\nimport { DEFAULT_BROWSER_HEADERS, DEFAULT_NODE_HEADERS } from \"./constants\";\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { UrbexHeaders } from \"../headers\";\r\nimport { clone, deepClone, isUndefined } from \"../../utils\";\r\n\r\n// here all of the interceptors are checked\r\n// cache clocks are checked here\r\n// the response is created here\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = deepClone(config);\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            // for some odd reason, result.cache had this weird mutation\r\n            // issue even when CLONING the result, so I had to do this\r\n            // to get it to work properly\r\n\r\n            // solved: the clone function that is internally provided\r\n            // only shallow clones the object, so the cache object\r\n            // was being mutated. It is now deep cloned.\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.create(config);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        await PipelineExecutor.process(config, config.pipelines.request);\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        let incomingResult = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            await PipelineExecutor.process(incomingResult, config.pipelines.response);\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { MethodsUpper } from \"./types\";\r\n\r\n// support for any protocols to be used with the uri component\r\n// currently only http and https are supported\r\n\r\n// regex to get the protocol from the uri component, can match anything\r\n// should return http or https\r\nexport const PROTOCOL_REGEXP = /^(?:([a-z]+):\\/\\/)?([^:\\/\\n]+)/i;\r\nexport const HOSTNAME_REGEXP = /^(?:https?:\\/\\/)?(?:[^@\\/\\n]+@)?([^:\\/\\n]+)/i;\r\nexport const PORT_REGEXP = /:(\\d{2,5})$/;\r\n\r\nexport const URL_REGEXP =\r\n    /^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$/i;\r\n\r\nexport const URI_TEMPLATE_REGEXP_LEFT = \"[{][^{{]*\\\\b\";\r\nexport const URI_TEMPLATE_REGEXP_RIGHT = \"\\\\b[^{}]*[}]\";\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { UrbexURL, URIComponent } from \"../exportable-types\";\r\nimport type { SearchParams } from \"../types\";\r\n\r\nimport {\r\n    URL_REGEXP,\r\n    HOSTNAME_REGEXP,\r\n    PROTOCOL_REGEXP,\r\n    URI_TEMPLATE_REGEXP_LEFT,\r\n    URI_TEMPLATE_REGEXP_RIGHT\r\n} from \"../constants\";\r\nimport {\r\n    isObject,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    ensureLeadingToken,\r\n    stringReplacer,\r\n    argumentIsNotProvided,\r\n    combinedStringss,\r\n    forEach,\r\n    merge,\r\n    isFunction,\r\n    isEmpty\r\n} from \"../utils\";\r\nimport { DEFAULT_URI_COMPONENT } from \"./constants\";\r\n\r\nexport type ParamSerializerType = \"string\" | \"object\" | \"URLSearchParams\";\r\n\r\n/**\r\n * Test if a url string has a valid protocol.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isProtocolURL(url: string): boolean {\r\n    return PROTOCOL_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url string has a valid hostname.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isHostnameURL(url: string): boolean {\r\n    return HOSTNAME_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url is valid\r\n */\r\nexport function isValidURL(url: string): boolean {\r\n    try {\r\n        new URL(url);\r\n\r\n        return true;\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function convertStringToURIComponent(input: string, urlMount = \"\"): URIComponent {\r\n    const url = new URL(input);\r\n\r\n    const protocol = stringReplacer(url.protocol, \":\", \"\") as string;\r\n    const port = url.port ? parseInt(url.port) : \"\";\r\n    const pathname = stringReplacer(url.pathname, urlMount, \"\");\r\n\r\n    return {\r\n        href: url.href,\r\n        origin: url.origin,\r\n        protocol: protocol,\r\n        hostname: url.hostname,\r\n        port: port,\r\n        endpoint: pathname,\r\n        params: url.search,\r\n        urlMount: urlMount\r\n    };\r\n}\r\n\r\n// turn this into its own package\r\nexport function convertURIComponentToString(input: Partial<URIComponent>): string {\r\n    let template = \"{protocol+://}{hostname}{:+port}{urlMount}{endpoint}{?+params}\";\r\n\r\n    function createRegexString(word: string): RegExp {\r\n        return new RegExp(`${URI_TEMPLATE_REGEXP_LEFT}${word}${URI_TEMPLATE_REGEXP_RIGHT}`, \"gi\");\r\n    }\r\n\r\n    if (argumentIsNotProvided(input) || isEmpty(input) || !isObject(input)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (input.params) {\r\n        input.params = serializeParams(input.params);\r\n    }\r\n\r\n    forEach(input, (key, value) => {\r\n        const regex = createRegexString(key);\r\n\r\n        if (argumentIsNotProvided(value) || isEmpty(value)) {\r\n            template = stringReplacer(template, regex, \"\");\r\n        } else {\r\n            const match = extractMatchFromRegExp(template, regex, 0, \"\");\r\n            const templateValue = stringReplacer(match, key, value.toString())\r\n                .replace(/\\+/g, \"\")\r\n                .replace(/^\\{/, \"\")\r\n                .replace(/\\}$/, \"\");\r\n\r\n            template = stringReplacer(template, match, templateValue);\r\n        }\r\n    });\r\n\r\n    return template;\r\n}\r\n\r\nexport function parseURIIntoComponent(\r\n    component: UrbexURL,\r\n    allowEndpoints = true\r\n): Partial<URIComponent> {\r\n    if (isString(component)) {\r\n        if (isValidURL(component)) {\r\n            return convertStringToURIComponent(component);\r\n        } else if (allowEndpoints) {\r\n            return {\r\n                endpoint: ensureLeadingToken(\"/\", component)\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                \"An invalid URL was provided. A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n            );\r\n        }\r\n    } else if (isObject(component)) {\r\n        const protocol = extractMatchFromRegExp(component.protocol, PROTOCOL_REGEXP, 0, \"http\");\r\n        const hostname = stringReplacer(\r\n            component.hostname,\r\n            new RegExp(`^${protocol}://`, \"gi\"),\r\n            \"\"\r\n        );\r\n\r\n        const endpoint = ensureLeadingToken(\"/\", component.endpoint);\r\n        const urlMount = ensureLeadingToken(\"/\", component.urlMount);\r\n\r\n        const buildableComponent = merge(component, {\r\n            protocol: protocol,\r\n            hostname: hostname,\r\n            endpoint: endpoint,\r\n            urlMount: urlMount\r\n        });\r\n\r\n        const componentAsString = convertURIComponentToString(buildableComponent);\r\n        const newComponent = convertStringToURIComponent(componentAsString, urlMount);\r\n\r\n        return newComponent;\r\n    } else {\r\n        throw new Error(\"Unable to parse the provided URI. Must be either a string or an object.\");\r\n    }\r\n}\r\n\r\nexport function serializeParams(\r\n    params: SearchParams,\r\n    serializerType: ParamSerializerType = \"string\"\r\n): Record<string, string> | string {\r\n    if (argumentIsNotProvided(params)) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const searchParams = new URLSearchParams(params);\r\n\r\n        if (serializerType === \"object\") {\r\n            const params = {};\r\n\r\n            searchParams.forEach((value, key) => {\r\n                params[key] = value;\r\n            });\r\n\r\n            return params;\r\n        }\r\n\r\n        return searchParams.toString();\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n","import type { InternalConfiguration, UrbexConfig, URIComponent } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { isValidURL, serializeParams, parseURIIntoComponent } from \"./url\";\r\nimport { PROTOCOL_REGEXP, HOSTNAME_REGEXP, METHODS } from \"../constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URI_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction determineAppropriateURI(): URIComponent {\r\n    const component = merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"https\",\r\n        urlMount: \"/api\"\r\n    });\r\n\r\n    if (environment.isBrowser) {\r\n        const { protocol, hostname, port } = window.location;\r\n\r\n        Object.assign(component, {\r\n            protocol: protocol.replace(\":\", \"\"),\r\n            hostname: hostname,\r\n            port: port\r\n        });\r\n    } else if (environment.isNode) {\r\n        Object.assign(component, {\r\n            protocol: \"http\",\r\n            hostname: \"localhost\",\r\n            port: 3000\r\n        });\r\n    }\r\n\r\n    return component;\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const component = parseURIIntoComponent(determineAppropriateURI());\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const configuration = deepMerge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: component,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: parseURIIntoComponent(determineAppropriateURI()),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        const configuration = clone(config);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const currentUrlConfig = this.get().url;\r\n\r\n            if (isObject(configuration.url)) {\r\n                // have to merge otherwise the uri parser may\r\n                // throw an error if fewer values are provided\r\n                configuration.url = merge(currentUrlConfig, configuration.url);\r\n            }\r\n\r\n            if (allowEndpoints && configuration.url.toString().startsWith(\"/\")) {\r\n                configuration.url = merge(currentUrlConfig, {\r\n                    endpoint: configuration.url\r\n                });\r\n            }\r\n\r\n            const parsed = parseURIIntoComponent(configuration.url, allowEndpoints);\r\n            configuration.url = parsed;\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(\r\n            configuration.timeout?.toString() ?? DEFAULT_CLIENT_OPTIONS.timeout.toString()\r\n        );\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(\r\n            configuration.maxContentLength?.toString() ??\r\n                DEFAULT_CLIENT_OPTIONS.maxContentLength.toString()\r\n        );\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n        delete configuration.headers;\r\n\r\n        return merge<UrbexConfig>(configuration, {\r\n            headers: headers\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers, incomingHeaders);\r\n\r\n        delete config.headers;\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n\r\n        return merge(merged, { headers: headersObject });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (url: UrbexURL, config?: UrbexMethodRequest) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n\r\nexport default urbex;\r\n"],"names":["environment","constructor","this","_context","detectContext","window","document","process","versions","node","Error","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","UrbexError","static","config","error","instance","create","call","request","TimeoutError","super","name","message","timeout","NetworkError","resolveRequest","resolve","reject","entity","status","response","statusCode","resolveStatus","createErrorInstance","errorMessage","statusMessage","statusText","hasOwnProperty","obj","prop","isUndefined","value","isArray","Array","isObject","isString","isFunction","isEmpty","length","Object","keys","uppercase","String","toUpperCase","deepClone","map","clone","key","merge","defaultOptions","options","assign","deepMerge","objects","reduce","acc","concat","forEach","fn","index","extractMatchFromRegExp","regexp","group","defaultValue","matches","exec","stringReplacer","search","replace","ensureLeadingToken","token","argumentIsNotProvided","startsWith","combinedStringss","delimiter","strings","filter","string","join","createEmptyScheme","split","object","nestedKeys","nestedObject","NodeRequest","getAgentFromProtocol","protocol","https","http","handleDataProtocolRequest","Promise","data","async","_resolve","_reject","agent","url","headers","has","set","params","toString","endsWith","href","hostname","path","endpoint","get","port","parseInt","isNaN","onData","push","onError","errorInstance","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","responseType","chunks","chunk","timeoutError","end","undefined","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","method","event","listener","open","includes","delete","setRequestHeader","bind","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","$executor","executor","pipelines","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","REQUEST_BODY_METHODS","DEFAULT_URI_COMPONENT","DEFAULT_PIPELINE_EXECUTORS","DEFAULT_CLIENT_OPTIONS","urlMount","cache","maxContentLength","Infinity","responseEncoding","DEFAULT_URBEX_RESPONSE","removeNewLines","parseHeaderKey","format","word","parsedWord","trim","charAt","slice","capitalize","formatHeaderKey","toLowerCase","parseHeaderValue","JSON","stringify","UrbexHeaders","$headers","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","console","normalizedHeaders","normalize","merged","headerKey","clear","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$cache","CacheClock","autoStart","debug","$api","configuration","concludeRequest","startTime","Date","now","timestamp","toISOString","clonedResponse","result","incomingResult","hit","parse","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","v","pulled","stored","isInstance","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","PROTOCOL_REGEXP","METHODS","convertStringToURIComponent","input","URL","pathname","origin","parseURIIntoComponent","component","allowEndpoints","isValidURL","RegExp","template","serializerType","searchParams","URLSearchParams","serializeParams","regex","match","templateValue","convertURIComponentToString","determineAppropriateURI","location","RequestConfig","setup","createConfigurationObject","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$maxCon","currentUrlConfig","construct","$config","_config$headers","currentConfig","incomingHeaders","mergedHeaders","reset","createMethodConfig","uri","UrbexClient","configure","stopCache","isRunning","stop","start","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","_","prototype","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}