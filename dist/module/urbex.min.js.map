{"version":3,"file":"urbex.min.js","sources":["../../lib/environment.ts","../../lib/core/error.ts","../../lib/core/api/resolve-request.ts","../../lib/utils.ts","../../lib/core/api/http.ts","../../lib/core/api/xhr.ts","../../lib/core/pipelines.ts","../../lib/core/constants.ts","../../lib/core/headers.ts","../../lib/debug.ts","../../lib/core/api/request-api.ts","../../lib/core/api/conclude.ts","../../lib/core/transformers.ts","../../lib/constants.ts","../../lib/core/url.ts","../../lib/core/request-config.ts","../../lib/core/urbex.ts","../../lib/urbex.ts"],"sourcesContent":["export type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\nexport class TimeoutError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = \"The request timed out.\";\r\n    }\r\n\r\n    public set timeout(timeout: number) {\r\n        this.message = `Timeout of ${timeout}ms exceeded`;\r\n    }\r\n}\r\n\r\nexport class NetworkError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = \"Failed to request the resource.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: any\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n    const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n    if (canResolve) {\r\n        return resolve(entity);\r\n    }\r\n\r\n    const error: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n    const errorMessage = `Request failed with status code ${status}`;\r\n\r\n    error.message = environment.isNode\r\n        ? entity.response.statusMessage\r\n        : entity.response.statusText ?? errorMessage;\r\n    error.request = this.request;\r\n    error.status = status;\r\n    error.response = entity.response;\r\n\r\n    return reject(error);\r\n}\r\n","import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(defaultOptions: P, options: T): P & T {\r\n    return Object.assign({}, defaultOptions, options);\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combinedStringss(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[]): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = null;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { Socket } from \"net\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi, DispatchedAPIRequest } from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combinedStringss, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            if (config.url.params && !isString(config.url.params)) {\r\n                config.url.params = config.url.params.toString();\r\n            } else {\r\n                config.url.params = \"\";\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combinedStringss(\"\", config.url.endpoint, config.url.params),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                const port = parseInt(config.url.port.toString());\r\n\r\n                if (!isNaN(port)) {\r\n                    options.port = port;\r\n                }\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError);\r\n                errorInstance.message = error.message;\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(UrbexError);\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError);\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject } from \"../utils\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult) || argumentIsNotProvided(pipelineResult)) {\r\n                throw new Error(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public execute(config: Parameters<T>): ReturnType<T> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { InternalConfiguration, URIComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { environment } from \"../environment\";\r\nimport { merge, createEmptyScheme } from \"../utils\";\r\n\r\nexport const DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nexport const DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const DEFAULT_URI_COMPONENT = createEmptyScheme<URIComponent>([\r\n    \"endpoint\",\r\n    \"hostname\",\r\n    \"href\",\r\n    \"origin\",\r\n    \"params\",\r\n    \"port\",\r\n    \"protocol\",\r\n    \"urlMount\"\r\n]);\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"http\",\r\n        urlMount: \"/api\"\r\n    }),\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\nimport { DEFAULT_BROWSER_HEADERS, DEFAULT_NODE_HEADERS } from \"./constants\";\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { UrbexHeaders } from \"../headers\";\r\nimport { clone, deepClone, isUndefined } from \"../../utils\";\r\n\r\n// here all of the interceptors are checked\r\n// cache clocks are checked here\r\n// the response is created here\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = deepClone(config);\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            // for some odd reason, result.cache had this weird mutation\r\n            // issue even when CLONING the result, so I had to do this\r\n            // to get it to work properly\r\n\r\n            // solved: the clone function that is internally provided\r\n            // only shallow clones the object, so the cache object\r\n            // was being mutated. It is now deep cloned.\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.create(config);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        await PipelineExecutor.process(config, config.pipelines.request);\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        let incomingResult = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            await PipelineExecutor.process(incomingResult, config.pipelines.response);\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { MethodsUpper } from \"./types\";\r\n\r\n// support for any protocols to be used with the uri component\r\n// currently only http and https are supported\r\n\r\n// regex to get the protocol from the uri component, can match anything\r\n// should return http or https\r\nexport const PROTOCOL_REGEXP = /^(?:([a-z]+):\\/\\/)?([^:\\/\\n]+)/i;\r\nexport const HOSTNAME_REGEXP = /^(?:https?:\\/\\/)?(?:[^@\\/\\n]+@)?([^:\\/\\n]+)/i;\r\nexport const PORT_REGEXP = /:(\\d{2,5})$/;\r\n\r\nexport const URL_REGEXP =\r\n    /^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$/i;\r\n\r\nexport const URI_TEMPLATE_REGEXP_LEFT = \"[{][^{{]*\\\\b\";\r\nexport const URI_TEMPLATE_REGEXP_RIGHT = \"\\\\b[^{}]*[}]\";\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { UrbexURL, URIComponent } from \"../exportable-types\";\r\nimport type { SearchParams } from \"../types\";\r\n\r\nimport {\r\n    URL_REGEXP,\r\n    HOSTNAME_REGEXP,\r\n    PROTOCOL_REGEXP,\r\n    URI_TEMPLATE_REGEXP_LEFT,\r\n    URI_TEMPLATE_REGEXP_RIGHT\r\n} from \"../constants\";\r\nimport {\r\n    isObject,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    ensureLeadingToken,\r\n    stringReplacer,\r\n    argumentIsNotProvided,\r\n    combinedStringss,\r\n    forEach,\r\n    merge,\r\n    isFunction,\r\n    isEmpty\r\n} from \"../utils\";\r\nimport { DEFAULT_URI_COMPONENT } from \"./constants\";\r\n\r\nexport type ParamSerializerType = \"string\" | \"object\" | \"URLSearchParams\";\r\n\r\n/**\r\n * Test if a url string has a valid protocol.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isProtocolURL(url: string): boolean {\r\n    return PROTOCOL_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url string has a valid hostname.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isHostnameURL(url: string): boolean {\r\n    return HOSTNAME_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url is valid\r\n */\r\nexport function isValidURL(url: string): boolean {\r\n    try {\r\n        new URL(url);\r\n\r\n        return true;\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function convertStringToURIComponent(input: string, urlMount = \"\"): URIComponent {\r\n    const url = new URL(input);\r\n\r\n    const protocol = stringReplacer(url.protocol, \":\", \"\") as string;\r\n    const port = url.port ? parseInt(url.port) : \"\";\r\n    const pathname = stringReplacer(url.pathname, urlMount, \"\");\r\n\r\n    return {\r\n        href: url.href,\r\n        origin: url.origin,\r\n        protocol: protocol,\r\n        hostname: url.hostname,\r\n        port: port,\r\n        endpoint: pathname,\r\n        params: url.search,\r\n        urlMount: urlMount\r\n    };\r\n}\r\n\r\n// turn this into its own package\r\nexport function convertURIComponentToString(input: Partial<URIComponent>): string {\r\n    let template = \"{protocol+://}{hostname}{:+port}{urlMount}{endpoint}{?+params}\";\r\n\r\n    function createRegexString(word: string): RegExp {\r\n        return new RegExp(`${URI_TEMPLATE_REGEXP_LEFT}${word}${URI_TEMPLATE_REGEXP_RIGHT}`, \"gi\");\r\n    }\r\n\r\n    if (argumentIsNotProvided(input) || isEmpty(input) || !isObject(input)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (input.params) {\r\n        input.params = serializeParams(input.params);\r\n    }\r\n\r\n    forEach(input, (key, value) => {\r\n        const regex = createRegexString(key);\r\n\r\n        if (argumentIsNotProvided(value) || isEmpty(value)) {\r\n            template = stringReplacer(template, regex, \"\");\r\n        } else {\r\n            const match = extractMatchFromRegExp(template, regex, 0, \"\");\r\n            const templateValue = stringReplacer(match, key, value.toString())\r\n                .replace(/\\+/g, \"\")\r\n                .replace(/^\\{/, \"\")\r\n                .replace(/\\}$/, \"\");\r\n\r\n            template = stringReplacer(template, match, templateValue);\r\n        }\r\n    });\r\n\r\n    return template;\r\n}\r\n\r\nexport function parseURIIntoComponent(\r\n    component: UrbexURL,\r\n    allowEndpoints = true\r\n): Partial<URIComponent> {\r\n    if (isString(component)) {\r\n        if (isValidURL(component)) {\r\n            return convertStringToURIComponent(component);\r\n        } else if (allowEndpoints) {\r\n            return {\r\n                endpoint: ensureLeadingToken(\"/\", component)\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                \"An invalid URL was provided. A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n            );\r\n        }\r\n    } else if (isObject(component)) {\r\n        const protocol = extractMatchFromRegExp(component.protocol, PROTOCOL_REGEXP, 0, \"http\");\r\n        const hostname = stringReplacer(\r\n            component.hostname,\r\n            new RegExp(`^${protocol}://`, \"gi\"),\r\n            \"\"\r\n        );\r\n\r\n        const endpoint = ensureLeadingToken(\"/\", component.endpoint);\r\n        const urlMount = ensureLeadingToken(\"/\", component.urlMount);\r\n\r\n        const buildableComponent = merge(component, {\r\n            protocol: protocol,\r\n            hostname: hostname,\r\n            endpoint: endpoint,\r\n            urlMount: urlMount\r\n        });\r\n\r\n        const componentAsString = convertURIComponentToString(buildableComponent);\r\n        const newComponent = convertStringToURIComponent(componentAsString, urlMount);\r\n\r\n        return newComponent;\r\n    } else {\r\n        throw new Error(\"Unable to parse the provided URI. Must be either a string or an object.\");\r\n    }\r\n}\r\n\r\nexport function serializeParams(\r\n    params: SearchParams,\r\n    serializerType: ParamSerializerType = \"string\"\r\n): Record<string, string> | string {\r\n    if (argumentIsNotProvided(params)) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const searchParams = new URLSearchParams(params);\r\n\r\n        if (serializerType === \"object\") {\r\n            const params = {};\r\n\r\n            searchParams.forEach((value, key) => {\r\n                params[key] = value;\r\n            });\r\n\r\n            return params;\r\n        }\r\n\r\n        return searchParams.toString();\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n","import type { InternalConfiguration, UrbexConfig, URIComponent } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { isValidURL, serializeParams, parseURIIntoComponent } from \"./url\";\r\nimport { PROTOCOL_REGEXP, HOSTNAME_REGEXP, METHODS } from \"../constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URI_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction determineAppropriateURI(): URIComponent {\r\n    const component = merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"https\",\r\n        urlMount: \"/api\"\r\n    });\r\n\r\n    if (environment.isBrowser) {\r\n        const { protocol, hostname, port } = window.location;\r\n\r\n        Object.assign(component, {\r\n            protocol: protocol.replace(\":\", \"\"),\r\n            hostname: hostname,\r\n            port: port\r\n        });\r\n    } else if (environment.isNode) {\r\n        Object.assign(component, {\r\n            protocol: \"http\",\r\n            hostname: \"localhost\",\r\n            port: 3000\r\n        });\r\n    }\r\n\r\n    return component;\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const component = parseURIIntoComponent(determineAppropriateURI());\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const configuration = deepMerge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: component,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: parseURIIntoComponent(determineAppropriateURI()),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        const configuration = clone(config);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const currentUrlConfig = this.get().url;\r\n\r\n            if (isObject(configuration.url)) {\r\n                // have to merge otherwise the uri parser may\r\n                // throw an error if fewer values are provided\r\n                configuration.url = merge(currentUrlConfig, configuration.url);\r\n            }\r\n\r\n            if (allowEndpoints && configuration.url.toString().startsWith(\"/\")) {\r\n                configuration.url = merge(currentUrlConfig, {\r\n                    endpoint: configuration.url\r\n                });\r\n            }\r\n\r\n            const parsed = parseURIIntoComponent(configuration.url, allowEndpoints);\r\n            configuration.url = parsed;\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(\r\n            configuration.timeout?.toString() ?? DEFAULT_CLIENT_OPTIONS.timeout.toString()\r\n        );\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(\r\n            configuration.maxContentLength?.toString() ??\r\n                DEFAULT_CLIENT_OPTIONS.maxContentLength.toString()\r\n        );\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n        delete configuration.headers;\r\n\r\n        return merge<UrbexConfig>(configuration, {\r\n            headers: headers\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers, incomingHeaders);\r\n\r\n        delete config.headers;\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n\r\n        return merge(merged, { headers: headersObject });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (url: UrbexURL, config?: UrbexMethodRequest) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n\r\nexport default urbex;\r\n"],"names":["environment","constructor","this","_context","detectContext","window","document","process","versions","node","Error","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","UrbexError","static","config","error","instance","create","call","request","TimeoutError","super","name","message","timeout","NetworkError","resolveRequest","resolve","reject","entity","_entity$response$stat","status","response","statusCode","resolveStatus","createErrorInstance","errorMessage","statusMessage","statusText","hasOwnProperty","obj","prop","isUndefined","value","isArray","Array","isObject","isString","isFunction","isEmpty","length","Object","keys","uppercase","String","toUpperCase","deepClone","map","clone","key","merge","defaultOptions","options","assign","deepMerge","_len","arguments","objects","_key","reduce","acc","concat","forEach","fn","index","extractMatchFromRegExp","regexp","group","defaultValue","matches","exec","stringReplacer","search","replace","ensureLeadingToken","token","argumentIsNotProvided","startsWith","combinedStringss","delimiter","_len2","strings","_key2","filter","string","join","createEmptyScheme","split","object","nestedKeys","nestedObject","NodeRequest","getAgentFromProtocol","protocol","https","http","handleDataProtocolRequest","Promise","data","async","_resolve","_reject","_config$data","agent","url","headers","has","set","params","toString","endsWith","href","hostname","path","endpoint","get","port","parseInt","isNaN","onData","push","onError","errorInstance","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","responseType","chunks","chunk","timeoutError","end","undefined","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","method","event","listener","open","includes","delete","setRequestHeader","bind","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","executor","_defineProperty","$executor","pipelines","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","REQUEST_BODY_METHODS","DEFAULT_URI_COMPONENT","DEFAULT_PIPELINE_EXECUTORS","DEFAULT_CLIENT_OPTIONS","urlMount","cache","maxContentLength","Infinity","responseEncoding","DEFAULT_URBEX_RESPONSE","removeNewLines","parseHeaderKey","format","word","parsedWord","trim","charAt","slice","capitalize","formatHeaderKey","toLowerCase","parseHeaderValue","JSON","stringify","UrbexHeaders","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","console","normalizedHeaders","normalize","merged","$headers","headerKey","clear","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$cache","CacheClock","autoStart","debug","$api","configuration","concludeRequest","startTime","Date","now","timestamp","toISOString","clonedResponse","result","incomingResult","hit","parse","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","v","pulled","stored","isInstance","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","PROTOCOL_REGEXP","METHODS","isValidURL","URL","convertStringToURIComponent","input","pathname","origin","convertURIComponentToString","template","serializerType","searchParams","URLSearchParams","serializeParams","regex","RegExp","match","templateValue","parseURIIntoComponent","component","allowEndpoints","determineAppropriateURI","location","RequestConfig","setup","createConfigurationObject","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$timeou2","_configuration$maxCon","_configuration$maxCon2","currentUrlConfig","construct","$config","_config$headers$get","_config$headers","currentConfig","incomingHeaders","mergedHeaders","reset","createMethodConfig","uri","UrbexClient","configure","stopCache","isRunning","stop","start","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","_","prototype","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}