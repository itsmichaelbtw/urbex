{"version":3,"file":"urbex.min.js","sources":["../../lib/utils.ts","../../lib/core/constants.ts","../../lib/core/parsers/base-url-parser.ts","../../lib/core/parsers/url-parser.ts","../../lib/environment.ts","../../lib/core/error.ts","../../lib/core/api/resolve-request.ts","../../lib/core/api/http.ts","../../lib/core/api/xhr.ts","../../lib/core/pipelines.ts","../../lib/core/headers.ts","../../lib/debug.ts","../../lib/core/api/request-api.ts","../../lib/core/api/conclude.ts","../../lib/core/transformers.ts","../../lib/core/request-config.ts","../../lib/core/urbex.ts","../../lib/urbex.ts"],"sourcesContent":["import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isNumber(value: unknown): value is number {\r\n    return typeof value === \"number\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(\r\n    defaultOptions: P,\r\n    options: T,\r\n    strict: boolean = false\r\n): P & T {\r\n    if (strict) {\r\n        const filteredOptions = keys(options).reduce((acc, key) => {\r\n            if (options[key]) {\r\n                acc[key] = options[key];\r\n            }\r\n\r\n            return acc;\r\n        }, {} as T);\r\n\r\n        return Object.assign({}, defaultOptions, filteredOptions);\r\n    } else {\r\n        return Object.assign({}, defaultOptions, options);\r\n    }\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combineStrings(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[], value = null): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = value;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import type { InternalConfiguration, URLComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { ParsedURLComponent, PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { createEmptyScheme } from \"../utils\";\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const URL_COMPONENT_KEYS: (keyof URLComponent)[] = [\r\n    \"href\",\r\n    \"origin\",\r\n    \"protocol\",\r\n    \"username\",\r\n    \"password\",\r\n    \"hostname\",\r\n    \"port\",\r\n    \"pathname\",\r\n    \"search\",\r\n    \"searchParams\",\r\n    \"hash\"\r\n];\r\n\r\nexport const DEFAULT_URL_COMPONENT = createEmptyScheme<ParsedURLComponent>(URL_COMPONENT_KEYS, \"\");\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: null,\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\n\r\nimport {\r\n    merge,\r\n    isString,\r\n    isNumber,\r\n    isEmpty,\r\n    isArray,\r\n    isObject,\r\n    createEmptyScheme,\r\n    lowercase,\r\n    combineStrings,\r\n    ensureTrailingToken,\r\n    ensureLeadingToken,\r\n    forEach\r\n} from \"../../utils\";\r\nimport { URL_COMPONENT_KEYS } from \"../constants\";\r\n\r\ninterface ParamsConversionOutput {\r\n    /**\r\n     * Stringified output of the search parameters.\r\n     */\r\n    search: string;\r\n    /**\r\n     * As a URLSearchParams object.\r\n     */\r\n    searchParams: URLSearchParams;\r\n}\r\n\r\nconst DEFAULT_PROTOCOL = \"http\";\r\n\r\nconst PARSE_URL =\r\n    /^(?:([^:\\/?#]+):)?(?:[\\/\\/]+((?:([^@\\/\\n]+)@)?((?:[0-9]{1,3}\\.){3}[0-9]{1,3}|\\[[0-9a-f:]+\\]|[^#:\\/?\\n]+)(?::(\\d*))?))?(?:[\\/]*([^?#]*))(?:[\\?]*([^#]*))?(?:[\\#]*(.*))?/i;\r\n\r\nconst IPV4_REGEX = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\r\nconst IPV6_REGEX = /^(\\[[0-9a-f:]+\\])$/i;\r\nconst AUTH_REGEX = /^([^:]+)(?:\\:([^:].+))?/;\r\nconst PORT_LOWER_LIMIT = 0;\r\nconst PORT_UPPER_LIMIT = 65535;\r\n\r\nfunction removeEncodedWhitespace(input: string): string {\r\n    return input.replace(/%20/g, \"\");\r\n}\r\n\r\nfunction normalizeIPv4(input: string): string {\r\n    const matches = IPV4_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        const numbers = matches.slice(1).map((num) => parseInt(num, 10));\r\n\r\n        if (numbers.every((num) => num <= 255)) {\r\n            return numbers.join(\".\");\r\n        }\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv4 address.\");\r\n}\r\n\r\nfunction normalizeIPv6(input: string): string {\r\n    const matches = IPV6_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        return matches[1];\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv6 address.\");\r\n}\r\n\r\nfunction formatPort(port: Port): string {\r\n    if (!port) {\r\n        return \"\";\r\n    }\r\n\r\n    if (isNumber(port) || !port.startsWith(\":\")) {\r\n        return `:${port}`;\r\n    } else {\r\n        return port;\r\n    }\r\n}\r\n\r\nexport function mergeAuth(username: string, password: string): string {\r\n    if (!username && password) {\r\n        throw new Error(\"Cannot set password without username.\");\r\n    }\r\n\r\n    if (!username) {\r\n        return \"\";\r\n    }\r\n\r\n    if (!password) {\r\n        return username;\r\n    }\r\n\r\n    return combineStrings(\":\", username, password);\r\n}\r\n\r\nexport function buildProtocol(protocol: string, hasHostname: boolean): string {\r\n    if (hasHostname || protocol === \"http\" || protocol === \"https\") {\r\n        return ensureTrailingToken(\"://\", protocol);\r\n    }\r\n\r\n    return ensureTrailingToken(\":\", protocol);\r\n}\r\n\r\nexport function extractScheme(input: string): string {\r\n    return input.replace(/:\\/\\/$/, \"\").replace(/:$/, \"\");\r\n}\r\n\r\nexport function convertSearchParamsToString(search: CustomSearchParams): ParamsConversionOutput {\r\n    if (!search || (!isString(search) && !isObject(search) && !isArray(search))) {\r\n        return {\r\n            search: \"\",\r\n            searchParams: null\r\n        };\r\n    }\r\n\r\n    if (isString(search)) {\r\n        return {\r\n            search: ensureLeadingToken(\"?\", removeEncodedWhitespace(search)),\r\n            searchParams: new URLSearchParams(search)\r\n        };\r\n    }\r\n\r\n    const searchParams = new URLSearchParams();\r\n\r\n    forEach(search, (key, value) => {\r\n        if (value) {\r\n            if (isArray(value)) {\r\n                const entry = value;\r\n                searchParams.append(entry[0] as string, entry[1] as string);\r\n            } else if (isObject(search)) {\r\n                searchParams.append(key, value);\r\n            }\r\n        }\r\n    });\r\n\r\n    return {\r\n        search: ensureLeadingToken(\"?\", searchParams.toString()),\r\n        searchParams: searchParams\r\n    };\r\n}\r\n\r\nexport class BaseURLParser {\r\n    protected $component: EnforceComponent;\r\n\r\n    constructor(input: string | SerializeComponent) {\r\n        if (input && !isString(input) && !isObject(input)) {\r\n            throw new TypeError(\"Invalid input. Must be a string or an object.\");\r\n        }\r\n\r\n        this.$component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        this.$component.searchParams = new URLSearchParams();\r\n\r\n        if (isString(input) && input) {\r\n            this.$component = this.parse(input);\r\n            return;\r\n        }\r\n\r\n        if (isObject(input) && !isEmpty(input)) {\r\n            if (input.href) {\r\n                this.$component = this.parse(input.href);\r\n            } else {\r\n                this.serialize(input);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    protected sync(\r\n        value: string,\r\n        replace: string,\r\n        syncType: \"all\" | \"href\" | \"origin\" = \"all\"\r\n    ): void {\r\n        const href = this.$component.href;\r\n        const origin = this.$component.origin;\r\n\r\n        if (value) {\r\n            if (syncType === \"all\" || syncType === \"href\") {\r\n                this.$component.href = href.replace(value, replace);\r\n            }\r\n\r\n            if (syncType === \"all\" || syncType === \"origin\") {\r\n                this.$component.origin = origin.replace(value, replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected syncAuth(origin: string, username: string, password: string): void {\r\n        if (!username) {\r\n            throw new Error(\"Cannot set password without username.\");\r\n        }\r\n\r\n        let [protocol, host] = origin.split(\"://\");\r\n\r\n        protocol = buildProtocol(protocol, !!host);\r\n\r\n        const authString = combineStrings(\"\", mergeAuth(username, password), \"@\");\r\n\r\n        this.$component.href = combineStrings(\"\", protocol, authString, host);\r\n    }\r\n\r\n    protected match(input: string): string[] {\r\n        return PARSE_URL.exec(input);\r\n    }\r\n\r\n    protected parseProtocol(input: string): string {\r\n        if (!input) {\r\n            const protocol = this.$component.protocol;\r\n            this.$component.protocol = protocol || DEFAULT_PROTOCOL;\r\n            return;\r\n        }\r\n\r\n        input = extractScheme(input);\r\n\r\n        const protocol = lowercase(removeEncodedWhitespace(input));\r\n        this.$component.protocol = protocol;\r\n    }\r\n\r\n    protected parseAuth(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const auth = AUTH_REGEX.exec(input);\r\n\r\n        if (auth && auth.length) {\r\n            const username = auth[1];\r\n            const password = auth[2];\r\n\r\n            if (!username) {\r\n                throw new Error(\"Expected username in auth.\");\r\n            }\r\n\r\n            this.$component.username = username;\r\n            this.$component.password = password || \"\";\r\n        } else {\r\n            throw new Error(\"Invalid auth format. Expected <username>:<password>\");\r\n        }\r\n    }\r\n\r\n    protected parseHostname(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const isIPv4 = IPV4_REGEX.test(input);\r\n\r\n        if (isIPv4) {\r\n            input = normalizeIPv4(input);\r\n        } else {\r\n            const isIPv6 = IPV6_REGEX.test(input);\r\n            if (isIPv6) {\r\n                input = normalizeIPv6(input);\r\n            } else {\r\n                input = lowercase(input);\r\n            }\r\n        }\r\n\r\n        this.$component.hostname = removeEncodedWhitespace(input);\r\n    }\r\n\r\n    protected parsePort(port: Port): void {\r\n        if (!port) {\r\n            this.$component.port = \"\";\r\n            return;\r\n        }\r\n\r\n        const parsePort = isNumber(port) ? port : parseInt(port, 10);\r\n\r\n        if (isNaN(parsePort) || parsePort < PORT_LOWER_LIMIT || parsePort > PORT_UPPER_LIMIT) {\r\n            throw new Error(\"Port must be between 0 and 65535.\");\r\n        }\r\n\r\n        this.$component.port = parsePort;\r\n    }\r\n\r\n    protected parseOrigin(origin: string): void {\r\n        const protocol = buildProtocol(this.$component.protocol, !!this.$component.hostname);\r\n\r\n        if (!origin || !this.$component.hostname) {\r\n            this.$component.origin = \"null\";\r\n        } else {\r\n            this.$component.origin = ensureLeadingToken(protocol, origin);\r\n        }\r\n\r\n        const authString = mergeAuth(this.$component.username, this.$component.password);\r\n\r\n        if (authString && this.$component.origin.includes(authString)) {\r\n            const replaceAuth = combineStrings(\"\", authString, \"@\");\r\n            this.$component.origin = this.$component.origin.replace(replaceAuth, \"\");\r\n        }\r\n    }\r\n\r\n    protected parsePathname(pathname: string): void {\r\n        if (!pathname) {\r\n            return;\r\n        }\r\n\r\n        if (this.$component.hostname) {\r\n            this.$component.pathname = ensureLeadingToken(\"/\", pathname);\r\n        } else {\r\n            this.$component.pathname = pathname;\r\n        }\r\n    }\r\n\r\n    protected parseParams(params: CustomSearchParams): void {\r\n        if (!params) {\r\n            return;\r\n        }\r\n\r\n        const search = convertSearchParamsToString(params);\r\n\r\n        if (search) {\r\n            this.$component.search = ensureLeadingToken(\"?\", search.search);\r\n            this.$component.searchParams = new URLSearchParams(search.searchParams);\r\n        }\r\n    }\r\n\r\n    protected parseHash(hash: string): void {\r\n        if (!hash) {\r\n            return;\r\n        }\r\n\r\n        this.$component.hash = ensureLeadingToken(\"#\", hash);\r\n    }\r\n\r\n    /**\r\n     * Parses a URL string and returns a URL object.\r\n     */\r\n    public parse(input: string, overwrite: boolean = true): EnforceComponent {\r\n        if (!isString(input) || isEmpty(input)) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        component.searchParams = new URLSearchParams();\r\n\r\n        if (overwrite) {\r\n            this.$component = component;\r\n        } else {\r\n            this.$component = merge(component, this.$component);\r\n        }\r\n\r\n        input = input.trim();\r\n        input = input.replace(/\\s/g, \"%20\");\r\n        input = input.replace(/\\\\/g, \"/\");\r\n\r\n        const matches = this.match(input);\r\n\r\n        if (matches === null || matches.length === 0) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const [href, protocol, origin, auth, hostname, port, pathname, query, hash] = matches;\r\n\r\n        this.parseProtocol(protocol);\r\n        this.parseAuth(auth);\r\n        this.parseHostname(hostname);\r\n        this.parsePort(port);\r\n        this.parsePathname(pathname);\r\n        this.parseParams(query);\r\n        this.parseHash(hash);\r\n        this.parseOrigin(origin);\r\n\r\n        this.$component.href = href;\r\n\r\n        return this.$component;\r\n    }\r\n\r\n    /**\r\n     * Serializes a URL object into a URL string.\r\n     */\r\n    public serialize(_component: SerializeComponent, overwrite: boolean = true): string {\r\n        const baseComponent = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        const component = merge(baseComponent, _component);\r\n\r\n        const tokens: string[] = [];\r\n\r\n        const authString = mergeAuth(component.username, component.password);\r\n\r\n        if (component.origin) {\r\n            const [_, protocol, origin, auth, host, port] = this.match(component.origin);\r\n\r\n            tokens.push(buildProtocol(protocol, !!host));\r\n\r\n            if (authString && !component.origin.includes(authString)) {\r\n                // this is a safe check to ensure the user didn't provide a username/password\r\n                // in the origin string. If they did, we'll remove it and use the one provided\r\n                // in the username/password properties.\r\n\r\n                const newOrigin = origin.replace(`${auth}@`, \"\");\r\n\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n                tokens.push(newOrigin);\r\n            } else {\r\n                if (auth) {\r\n                    tokens.push(auth);\r\n                    tokens.push(\"@\");\r\n                }\r\n\r\n                tokens.push(host);\r\n\r\n                if (port) {\r\n                    tokens.push(formatPort(port));\r\n                }\r\n            }\r\n        } else {\r\n            if (!component.protocol) {\r\n                throw new Error(\"Expected a protocol when serializing a URL.\");\r\n            }\r\n\r\n            if (component.protocol === \"http\" || component.protocol === \"https\") {\r\n                if (!component.hostname) {\r\n                    throw new Error(\r\n                        \"Expected a hostname when serializing a URL with an HTTP protocol.\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            tokens.push(buildProtocol(component.protocol, !!component.hostname));\r\n\r\n            if (authString) {\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n            }\r\n\r\n            if (component.hostname) {\r\n                tokens.push(component.hostname);\r\n            }\r\n\r\n            tokens.push(formatPort(component.port));\r\n        }\r\n\r\n        tokens.push(ensureLeadingToken(\"/\", component.pathname));\r\n\r\n        const searchParams = component.search || component.searchParams || \"\";\r\n\r\n        if (searchParams) {\r\n            if (searchParams instanceof URLSearchParams) {\r\n                const search = searchParams.toString();\r\n\r\n                if (search) {\r\n                    tokens.push(ensureLeadingToken(\"?\", search));\r\n                }\r\n            } else {\r\n                const { search } = convertSearchParamsToString(searchParams.toString());\r\n                tokens.push(ensureLeadingToken(\"?\", search));\r\n            }\r\n        }\r\n\r\n        if (component.hash) {\r\n            tokens.push(ensureLeadingToken(\"#\", component.hash));\r\n        }\r\n\r\n        const url = tokens.filter((token) => token && token !== \"/\").join(\"\");\r\n\r\n        try {\r\n            const parsed = this.parse(url, overwrite);\r\n            return parsed.href;\r\n        } catch (error) {\r\n            throw new Error(\"Attempted to serialize an invalid URL.\");\r\n        }\r\n    }\r\n}\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\nimport { combineStrings, ensureLeadingToken } from \"../../utils\";\r\n\r\nimport {\r\n    BaseURLParser,\r\n    mergeAuth,\r\n    extractScheme,\r\n    buildProtocol,\r\n    convertSearchParamsToString\r\n} from \"./base-url-parser\";\r\nimport { merge } from \"../../utils\";\r\n\r\n// build this as a seperate package\r\n\r\n/**\r\n * The internal URL parser that is responsible for parsing and serializing\r\n * URLs and their components.\r\n */\r\nexport class URLParser extends BaseURLParser {\r\n    constructor(input?: string | SerializeComponent) {\r\n        super(input);\r\n    }\r\n\r\n    /**\r\n     * Parse the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static parse(input: string): URLParser {\r\n        return new this(input);\r\n    }\r\n\r\n    /**\r\n     * Serialize the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static serialize(component: SerializeComponent): string {\r\n        return new this().serialize(component);\r\n    }\r\n\r\n    /**\r\n     * Set a component object without enforcing the component to serialize\r\n     * or parse. Merges the component with the existing component.\r\n     *\r\n     * This does not validate the component.\r\n     */\r\n    public set(component: SerializeComponent): this {\r\n        this.$component = merge(this.$component, component);\r\n\r\n        if (component.searchParams instanceof URLSearchParams) {\r\n            this.$component.search = component.searchParams.toString();\r\n            this.$component.searchParams = component.searchParams;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public get href(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public set href(value: string) {\r\n        this.parse(value);\r\n    }\r\n\r\n    public get origin(): string {\r\n        return this.$component.origin;\r\n    }\r\n\r\n    public set origin(value: string) {\r\n        const [href, protocol, origin, auth, hostname, port] = this.match(value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        const component = merge<EnforceComponent, SerializeComponent>(this.$component, {\r\n            href: \"\",\r\n            origin: combineStrings(\"\", buildProtocol(protocol, !!hostname), origin)\r\n        });\r\n\r\n        this.serialize(component);\r\n    }\r\n\r\n    public get protocol(): string {\r\n        return this.$component.protocol;\r\n    }\r\n\r\n    public set protocol(value: string) {\r\n        if (value === this.protocol) {\r\n            return;\r\n        }\r\n\r\n        const existing = buildProtocol(this.protocol, !!this.hostname);\r\n        const incoming = buildProtocol(extractScheme(value), !value.includes(\"data\"));\r\n\r\n        this.parseProtocol(value);\r\n\r\n        this.sync(existing, incoming);\r\n    }\r\n\r\n    public get username(): string {\r\n        return this.$component.username;\r\n    }\r\n\r\n    public set username(value: string) {\r\n        const existing = this.username;\r\n\r\n        if (value === this.username) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(value, this.password);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get password(): string {\r\n        return this.$component.password;\r\n    }\r\n\r\n    public set password(value: string) {\r\n        const existing = this.password;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(this.username, value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get hostname(): string {\r\n        return this.$component.hostname;\r\n    }\r\n\r\n    public set hostname(value: string) {\r\n        const existing = this.hostname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHostname(value);\r\n        this.sync(existing, this.hostname);\r\n    }\r\n\r\n    public get port(): Port {\r\n        return this.$component.port;\r\n    }\r\n\r\n    public set port(value: Port) {\r\n        const existing = this.port.toString();\r\n\r\n        if (value.toString() === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePort(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.port.toString());\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const originWithPort = combineStrings(\":\", origin, this.port.toString());\r\n\r\n            this.sync(origin, originWithPort);\r\n        }\r\n    }\r\n\r\n    public get pathname(): string {\r\n        return this.$component.pathname;\r\n    }\r\n\r\n    public set pathname(value: string) {\r\n        const existing = this.pathname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePathname(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.pathname);\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const pathname = ensureLeadingToken(\"/\", this.pathname);\r\n            const originwithPathname = combineStrings(\"\", origin, pathname);\r\n\r\n            this.sync(origin, originwithPathname, \"href\");\r\n        }\r\n    }\r\n\r\n    public get search(): string {\r\n        return convertSearchParamsToString(this.$component.search).search;\r\n    }\r\n\r\n    public get searchParams(): URLSearchParams {\r\n        return this.$component.searchParams;\r\n    }\r\n\r\n    public get hash(): string {\r\n        return this.$component.hash;\r\n    }\r\n\r\n    public set hash(value: string) {\r\n        const existing = this.hash;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHash(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.hash, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const hash = ensureLeadingToken(\"#\", this.hash);\r\n            const originwithHash = combineStrings(\"\", origin, hash);\r\n\r\n            this.sync(origin, originwithHash, \"href\");\r\n        }\r\n    }\r\n\r\n    public setSearchParams(value: CustomSearchParams | URLSearchParams, merge: boolean = false) {\r\n        const existing = this.search;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        if (value instanceof URLSearchParams) {\r\n            value = value.toString();\r\n        }\r\n\r\n        this.parseParams(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.search, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const search = ensureLeadingToken(\"?\", this.search);\r\n            const originwithSearch = combineStrings(\"\", origin, search);\r\n\r\n            this.sync(origin, originwithSearch, \"href\");\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public toJSON(): EnforceComponent {\r\n        return this.$component;\r\n    }\r\n}\r\n","import { URLParser } from \"./core/parsers/url-parser\";\r\n\r\nexport type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n\r\n    public getEnvironmentComponent(): URLParser {\r\n        if (this.isBrowser) {\r\n            return URLParser.parse(window.location.href);\r\n        } else {\r\n            const port = process.env.PORT || \"3000\";\r\n            const parsed = URLParser.parse(`http://localhost:${port}`);\r\n\r\n            return parsed;\r\n        }\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nfunction replaceCallStackWithName(stack: string, name: string): string {\r\n    return stack.replace(/^Error/, name);\r\n}\r\n\r\n/**\r\n * Base error class for Urbex that extends the native Error class.\r\n */\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n    message: string = \"An error occurred while executing a request.\";\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n        error.name = this.name;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createFromError<T extends typeof UrbexError>(this: T, error: Error): InstanceType<T> {\r\n        if (!(error instanceof Error)) {\r\n            error = new Error(error);\r\n        }\r\n\r\n        const instance = new this(error.message);\r\n\r\n        if (error.stack) {\r\n            instance.stack = replaceCallStackWithName(error.stack, this.name);\r\n        }\r\n\r\n        instance.name = this.name;\r\n\r\n        if (UrbexError.isInstance(error)) {\r\n            instance.name = error.name;\r\n        }\r\n\r\n        return instance as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\n/**\r\n * A TimeoutError is thrown when the request takes longer than the specified timeout.\r\n */\r\nexport class TimeoutError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = message || \"The request timed out.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A NetworkError is thrown when the request fails to reach the server.\r\n */\r\nexport class NetworkError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = message || \"Failed to request the resource.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A PipelineError is thrown when executing a pipeline fails.\r\n */\r\nexport class PipelineError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"PipelineError\";\r\n        this.message = message || \"An error occurred while executing a pipeline.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { ResolvableEntity } from \"../../types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: ResolvableEntity\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n\r\n    try {\r\n        const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n        if (canResolve) {\r\n            return resolve(entity);\r\n        }\r\n\r\n        const errorInstance: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n\r\n        errorInstance.status = status;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.request = this.request;\r\n\r\n        if (environment.isNode) {\r\n            errorInstance.message = entity.response.statusMessage;\r\n        } else {\r\n            errorInstance.message = entity.response.statusText;\r\n        }\r\n\r\n        if (!errorInstance.message) {\r\n            errorInstance.message = `Request failed with status code ${status}`;\r\n        }\r\n\r\n        return reject(errorInstance);\r\n    } catch (error) {\r\n        const errorInstance: UrbexError = UrbexError.createFromError.call(UrbexError, error);\r\n\r\n        errorInstance.message = error.message;\r\n        errorInstance.config = this.config;\r\n        errorInstance.request = this.request;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.status = status;\r\n\r\n        return reject(errorInstance);\r\n    }\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combineStrings, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combineStrings(\"\", config.url.pathname, config.url.search),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                options.port = config.url.port;\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError, error);\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","/* istanbul ignore file */\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(\r\n                    UrbexError,\r\n                    new Error(\"Request was aborted\")\r\n                );\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError, new Error(\"Network Error\"));\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject, forEach, isString } from \"../utils\";\r\nimport { PipelineError } from \"../core/error\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            if (!(pipeline instanceof PipelineExecutor)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid pipeline to be passed to the `process` method.\"\r\n                );\r\n            }\r\n\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public async execute(config: Parameters<T>): Promise<ReturnType<T>> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\n\r\nconst DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nconst DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { isUndefined } from \"../../utils\";\r\nimport { DEFAULT_CLIENT_OPTIONS } from \"../constants\";\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = config;\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.createFromError.call(UrbexError, error);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\nimport { UrbexError, PipelineError } from \"../error\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        try {\r\n            await PipelineExecutor.process<InternalConfiguration, RequestExecutor>(\r\n                config,\r\n                config.pipelines.request\r\n            );\r\n        } catch (error) {\r\n            const errorInstance: UrbexError = UrbexError.createFromError.call(PipelineError, error);\r\n            errorInstance.config = config;\r\n            return Promise.reject(errorInstance);\r\n        }\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        const incomingResult: UrbexResponse = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache.\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            try {\r\n                await PipelineExecutor.process<UrbexResponse, ResponseExecutor>(\r\n                    incomingResult,\r\n                    config.pipelines.response\r\n                );\r\n            } catch (error) {\r\n                const errorInstance: UrbexError = UrbexError.createFromError.call(\r\n                    PipelineError,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = incomingResult.request;\r\n                errorInstance.response = incomingResult.response;\r\n                errorInstance.status = incomingResult.status;\r\n                return Promise.reject(errorInstance);\r\n            }\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { InternalConfiguration, UrbexConfig, UrbexURL } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport { URLParser } from \"./parsers/url-parser\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { METHODS } from \"./constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URL_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction isPathname(pathname: string): boolean {\r\n    if (!pathname.startsWith(\"//\") && pathname.startsWith(\"/\")) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction manageURLComponent(this: URLParser, component: UrbexURL, allowEndpoints: boolean): void {\r\n    if (isString(component)) {\r\n        const hasPathname = isPathname(component);\r\n\r\n        if (hasPathname) {\r\n            if (allowEndpoints) {\r\n                this.pathname = component;\r\n            } else {\r\n                throw new Error(\r\n                    \"A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n                );\r\n            }\r\n        } else {\r\n            this.parse(component);\r\n        }\r\n    } else {\r\n        // the serializer always uses the origin if passed\r\n        // however this conflicts if the configuration method\r\n        // is called multiple times attempting to change\r\n        // components of the URL. By default, the origin will always\r\n        // be present since it was parsed previously and will fail to\r\n        // adjust the other components.\r\n\r\n        // to fix this, if the origin is not passed, we will\r\n        // set it to an empty string so that the serializer\r\n        // will not use it.\r\n\r\n        if (component.origin === undefined) {\r\n            component.origin = \"\";\r\n        }\r\n\r\n        component.href ? this.parse(component.href) : this.set(component).serialize(this.toJSON());\r\n    }\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        /* istanbul ignore if */\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const envComponent = environment.getEnvironmentComponent();\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const options = deepClone(DEFAULT_CLIENT_OPTIONS);\r\n\r\n        const configuration = deepMerge(options, {\r\n            url: envComponent,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: environment.getEnvironmentComponent(),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        if (isEmpty(config)) {\r\n            return {};\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const configuration = clone(config);\r\n\r\n        const clonedUrl = clone(currentConfig.url.toJSON());\r\n        const parser = new URLParser();\r\n\r\n        parser.set(clonedUrl);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const url = configuration.url;\r\n\r\n            if (!isString(url) && !isObject(url)) {\r\n                throw new Error(\"The url property must be a string or an object.\");\r\n            }\r\n\r\n            manageURLComponent.call(parser, url, allowEndpoints);\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(configuration.timeout?.toString(), 10);\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(configuration.maxContentLength?.toString(), 10);\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n\r\n        configuration.headers = null;\r\n        configuration.url = null;\r\n\r\n        return merge<UrbexConfig, Partial<InternalConfiguration>>(configuration, {\r\n            headers: headers,\r\n            url: parser\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config) || isEmpty(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n        const incomingComponent = config.url?.toJSON() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers.get(), incomingHeaders);\r\n        const mergedComponent = merge(currentConfig.url.toJSON(), incomingComponent);\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n        const componentObject = new URLParser();\r\n\r\n        componentObject.set(mergedComponent);\r\n\r\n        return merge<InternalConfiguration, Partial<InternalConfiguration>>(merged, {\r\n            headers: headersObject,\r\n            url: componentObject\r\n        });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    public get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    public get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            /* istanbul ignore next */\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n// export * from \"./core/headers\";\r\nexport * from \"./core/parsers/url-parser\";\r\nexport * from \"./core/error\";\r\n\r\nexport default urbex;\r\n"],"names":["hasOwnProperty","obj","prop","call","isUndefined","value","isArray","Array","isObject","isString","isFunction","isNumber","isEmpty","length","Object","keys","uppercase","String","toUpperCase","lowercase","toLowerCase","clone","slice","assign","deepClone","map","constructor","key","merge","defaultOptions","options","strict","filteredOptions","reduce","acc","deepMerge","_len","arguments","objects","_key","concat","forEach","fn","index","ensureLeadingToken","token","argumentIsNotProvided","startsWith","ensureTrailingToken","endsWith","combineStrings","delimiter","_len2","strings","_key2","filter","string","join","createEmptyScheme","split","object","nestedKeys","nestedObject","REQUEST_BODY_METHODS","URL_COMPONENT_KEYS","DEFAULT_PIPELINE_EXECUTORS","request","response","DEFAULT_CLIENT_OPTIONS","url","timeout","method","headers","data","cache","pipelines","maxContentLength","Infinity","responseType","responseEncoding","resolveStatus","config","status","DEFAULT_URBEX_RESPONSE","METHODS","PARSE_URL","IPV4_REGEX","IPV6_REGEX","AUTH_REGEX","removeEncodedWhitespace","input","replace","formatPort","port","mergeAuth","username","password","Error","buildProtocol","protocol","hasHostname","extractScheme","convertSearchParamsToString","search","searchParams","URLSearchParams","entry","append","toString","BaseURLParser","TypeError","this","$component","parse","href","serialize","sync","syncType","origin","syncAuth","host","authString","match","exec","parseProtocol","parseAuth","auth","parseHostname","test","matches","numbers","num","parseInt","every","normalizeIPv4","normalizeIPv6","hostname","parsePort","isNaN","parseOrigin","includes","replaceAuth","parsePathname","pathname","parseParams","params","parseHash","hash","overwrite","component","trim","query","_component","tokens","_","push","newOrigin","error","URLParser","super","static","set","existing","incoming","originWithPort","originwithPathname","originwithHash","setSearchParams","originwithSearch","toJSON","environment","_context","detectContext","window","document","process","versions","node","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","getEnvironmentComponent","location","PORT","UrbexError","_defineProperty","name","instance","create","message","stack","isInstance","TimeoutError","NetworkError","PipelineError","resolveRequest","resolve","reject","entity","statusCode","errorInstance","createErrorInstance","statusMessage","statusText","createFromError","NodeRequest","getAgentFromProtocol","https","http","handleDataProtocolRequest","Promise","async","_resolve","_reject","_config$data","agent","has","path","get","onData","onError","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","chunks","chunk","timeoutError","end","undefined","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","event","listener","open","delete","setRequestHeader","bind","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","executor","$executor","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","removeNewLines","stringReplacer","parseHeaderKey","format","word","parsedWord","charAt","formatHeaderKey","parseHeaderValue","JSON","stringify","UrbexHeaders","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","console","normalizedHeaders","normalize","merged","$headers","headerKey","clear","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$cache","CacheClock","autoStart","debug","$api","configuration","concludeRequest","startTime","Date","now","timestamp","toISOString","clonedResponse","result","incomingResult","hit","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","v","pulled","stored","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","manageURLComponent","allowEndpoints","RequestConfig","setup","createConfigurationObject","envComponent","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$maxCon","currentConfig","clonedUrl","parser","construct","$config","_config$headers$get","_config$headers","_config$url$toJSON","_config$url","incomingHeaders","incomingComponent","mergedHeaders","mergedComponent","headersObject","componentObject","reset","createMethodConfig","uri","UrbexClient","configure","stopCache","isRunning","stop","start","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","prototype","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}