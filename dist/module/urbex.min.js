/**
    * https://github.com/orison-networks/urbex#readme
    * (c) 2022 Orison Networks
    * @license MIT
    */

import { CacheClock } from 'cache-clock';
import http from 'http';
import https from 'https';
import zlib from 'zlib';
import util from 'util';

class Environment {
  constructor() {
    this._context = this.detectContext();
  }
  detectContext() {
    if (typeof window !== "undefined" && typeof window.document !== "undefined") {
      return "browser";
    }
    if (typeof process !== "undefined" && process.versions && process.versions.node) {
      return "node";
    }
    throw new Error("Unable to detect environment context.");
  }
  nodeStrictCheck() {
    if (this.isBrowser) {
      throw new Error("This method is not available in the browser environment.");
    }
  }
  get process() {
    if (this.isNode) {
      return process;
    }
    return {};
  }
  get context() {
    return this._context;
  }
  get isBrowser() {
    return this.context === "browser";
  }
  get isNode() {
    return this.context === "node";
  }
  get isDevelopment() {
    this.nodeStrictCheck();
    return process.env.NODE_ENV === "development";
  }
  get isProduction() {
    this.nodeStrictCheck();
    return process.env.NODE_ENV === "production";
  }
}
const environment = new Environment();

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

/**
 * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.
 */
function hasOwnProperty(obj, prop) {
  return obj.hasOwnProperty.call(obj, prop);
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isArray(value) {
  return Array.isArray(value);
}
function isObject(value) {
  return typeof value === "object" && value !== null && !isArray(value);
}
function isString(value) {
  return typeof value === "string";
}
function isFunction(value) {
  return typeof value === "function";
}
function isEmpty(value) {
  if (isArray(value)) {
    return value.length === 0;
  } else if (isObject(value)) {
    return Object.keys(value).length === 0;
  } else {
    return !value;
  }
}
function capitalize(value) {
  value = String(value);
  return value.charAt(0).toUpperCase() + value.slice(1);
}
function uppercase(value) {
  return String(value).toUpperCase();
}
function clone(value) {
  if (isArray(value)) {
    return value.slice();
  } else if (isObject(value)) {
    return Object.assign({}, value);
  } else {
    return value;
  }
}
function merge(defaultOptions, options) {
  return Object.assign({}, defaultOptions, options);
}
function deepMerge() {
  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
    objects[_key] = arguments[_key];
  }
  return objects.reduce((acc, obj) => {
    if (isArray(obj)) {
      return acc.concat(obj);
    }
    for (const key in obj) {
      if (isArray(acc[key]) && isArray(obj[key])) {
        acc[key] = acc[key].concat(obj[key]);
      } else if (isObject(acc[key]) && isObject(obj[key])) {
        acc[key] = deepMerge(acc[key], obj[key]);
      } else {
        acc[key] = obj[key];
      }
    }
    return acc;
  }, {});
}
function forEach(obj, fn) {
  if (isUndefined(obj)) {
    return;
  }
  if (isArray(obj)) {
    obj.forEach(function (value, index) {
      fn.call(null, index, value, obj);
    });
  } else {
    for (const key in obj) {
      fn.call(null, key, obj[key], obj);
    }
  }
}
function extractMatchFromRegExp(value, regexp) {
  let group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  if (value) {
    const matches = regexp.exec(value);
    if (isArray(matches) && !isEmpty(matches)) {
      return matches[group];
    }
  }
  return defaultValue;
}
function stringReplacer(value, search, replace) {
  return value.replace(search, replace);
}
function ensureLeadingToken(token, value) {
  if (argumentIsNotProvided(value)) {
    return "";
  }
  if (value.startsWith(token)) {
    return value;
  }
  return `${token}${value}`;
}
function ensureTrailingToken(token, value) {
  if (argumentIsNotProvided(value)) {
    return "";
  }
  if (value.endsWith(token)) {
    return value;
  }
  return `${value}${token}`;
}
function argumentIsNotProvided(value) {
  return value === undefined || value === null;
}
function combineStrings() {
  let delimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  for (var _len2 = arguments.length, strings = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    strings[_key2 - 1] = arguments[_key2];
  }
  return strings.filter(string => !isEmpty(string)).join(delimiter);
}
function createEmptyScheme(keys) {
  return keys.reduce((acc, key) => {
    const keys = key.split(".");
    if (keys.length === 1) {
      acc[key] = null;
    } else {
      const [object, ...nestedKeys] = keys;
      if (!acc[object]) {
        acc[object] = {};
      }
      const nestedObject = createEmptyScheme(nestedKeys);
      acc[object] = merge(acc[object], nestedObject);
    }
    return acc;
  }, {});
}

class UrbexError extends Error {
  constructor(error) {
    if (!(error instanceof Error)) {
      error = new Error(error);
    }
    super(error.message);
    this.name = error.name;
    this.stack = error.stack;
  }
  static create(error, config, response) {
    const urbexError = new UrbexError(error);
    urbexError.config = config;
    urbexError.response = response;
    urbexError.status = response.status;
    urbexError.request = config;
    return urbexError;
  }
}
class TimeoutError extends UrbexError {
  constructor(timeout) {
    const error = new Error(`Request timed out after ${timeout}ms.`);
    super(error);
  }
}

class NodeRequest {
  getAgentFromProtocol(protocol) {
    if (protocol === "https") {
      return https;
    }
    return http;
  }
  handleDataProtocolRequest(config) {
    return new Promise((resolve, reject) => {
      resolve({
        data: null,
        request: null,
        response: null
      });
    });
  }
  async send(config) {
    return new Promise((resolve, reject) => {
      var _config$data;
      const agent = this.getAgentFromProtocol(config.url.protocol);
      if (config.url.protocol === "data") {
        return this.handleDataProtocolRequest(config);
      }
      if (!config.headers.has("Accept-Encoding")) {
        config.headers.set({
          "Accept-Encoding": "gzip, deflate, br"
        });
      }
      if (config.url.params && !isString(config.url.params)) {
        config.url.params = config.url.params.toString();
      } else {
        config.url.params = "";
      }
      function onError(error) {
        const err = new UrbexError(error);
        err.config = config;
        err.request = request;
        return reject(err);
      }
      const options = {
        protocol: ensureTrailingToken(":", config.url.protocol),
        href: config.url.href,
        hostname: config.url.hostname,
        path: combineStrings("", config.url.endpoint, config.url.params),
        headers: config.headers.get(),
        timeout: config.timeout
      };
      if (config.url.port) {
        const port = parseInt(config.url.port.toString());
        if (!isNaN(port)) {
          options.port = port;
        }
      }
      const request = agent.request(options);
      request.on("response", response => {
        if (response.destroyed || request.destroyed) {
          return onError(new UrbexError("Request was destroyed."));
        }
        if (config.responseType === "stream") {
          return resolve({
            data: response,
            request: request,
            response: response
          });
        }
        const chunks = [];
        response.on("data", chunks.push.bind(chunks));
        response.on("error", onError);
        response.on("close", () => {
          if (response.complete) {
            return;
          }
          response.destroy();
          request.destroy();
          return onError(new UrbexError("Request was closed prematurely."));
        });
        response.on("end", () => {
          const body = Buffer.concat(chunks);
          resolve({
            data: body,
            request: request,
            response: response
          });
        });
      });
      if (config.timeout) {
        request.setTimeout(config.timeout, () => {
          reject(new TimeoutError(config.timeout));
        });
      }
      request.on("error", onError);
      request.end((_config$data = config.data) !== null && _config$data !== void 0 ? _config$data : undefined);
    });
  }
}
const br = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;
const gzip = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.gunzip) ? util.promisify(zlib.gunzip) : null;
const deflate = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.inflate) ? util.promisify(zlib.inflate) : null;
const compress = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.createUnzip) ? util.promisify(zlib.createUnzip) : null;
const DECODERS = {
  br,
  gzip,
  deflate,
  compress
};

class BrowserRequest {
  send(config) {
    return new Promise(() => {});
  }
}
createEmptyScheme(["br", "gzip", "deflate", "compress"]);

const DEFAULT_BROWSER_HEADERS = {
  "Content-Type": "application/json"
};
const DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {
  "User-Agent": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`
});
const DEFAULT_URI_COMPONENT = createEmptyScheme(["endpoint", "hostname", "href", "origin", "params", "port", "protocol", "urlMount"]);
const DEFAULT_PIPELINE_EXECUTORS = {
  request: [],
  response: []
};
const DEFAULT_CLIENT_OPTIONS = {
  url: merge(DEFAULT_URI_COMPONENT, {
    protocol: "http",
    urlMount: "/api"
  }),
  timeout: 0,
  method: "GET",
  headers: null,
  data: null,
  cache: {},
  pipelines: DEFAULT_PIPELINE_EXECUTORS,
  maxContentLength: Infinity,
  responseType: "json",
  responseEncoding: "utf8"
};
const DEFAULT_URBEX_RESPONSE = createEmptyScheme(["status", "statusText", "headers", "data", "config", "request", "response", "duration", "timestamp", "cache.key", "cache.hit", "cache.pulled", "cache.stored"]);

async function startRequest(config) {
  const startTime = Date.now();
  const timestamp = new Date().toISOString();
  const clonedResponse = clone(DEFAULT_URBEX_RESPONSE);
  if (!isEmpty(config.pipelines.request)) {
    // loop over the request pipelines
    // each pipeline is a Promise that returns a new config
    // each new config is passed to the next pipeline
    // the very last config will mutate the `config` parameter

    for (const pipeline of config.pipelines.request) {
      config = await pipeline.execute(config);
      if (config === null) {
        throw new Error("Urbex expected a valid configuration to be returned from a request pipeline, but got null.");
      }
    }
  }

  // all of the request pipelines are executed here

  return async function concludeRequest(result) {
    const incomingResult = result;

    // all of the response pipelines are executed here

    let response = deepMerge(clonedResponse, {
      data: incomingResult.data,
      config: config,
      request: incomingResult.request,
      response: incomingResult.response,
      timestamp: timestamp,
      responseType: config.responseType
    });
    if (incomingResult.response) {
      response.headers = incomingResult.response.headers;
      response.status = incomingResult.response.statusCode;
      response.statusText = incomingResult.response.statusMessage;
    }
    if (!isEmpty(config.pipelines.response)) {
      for (const pipeline of config.pipelines.response) {
        response = await pipeline.execute(response);
      }
    }
    const endTime = Date.now();
    const duration = endTime - startTime;
    response.duration = duration;
    return Promise.resolve(response);
  };
}

// here all of the interceptors are checked
// cache clocks are checked here
// the response is created here

class RequestApi {
  /**
   * The internal api that is used to send requests.
   */

  /**
   * An isolated cache module that is used to cache requests.
   */

  constructor() {
    this.register(environment.context);
    this.$cache = new CacheClock({
      autoStart: false,
      debug: false
    });
  }
  register(context) {
    if (context === "browser") {
      this.$api = new BrowserRequest();
      return;
    }
    if (context === "node") {
      this.$api = new NodeRequest();
      return;
    }
    throw new Error(`Urbex expected a valid context to register a request api, but got ${context}.`);
  }
  async dispatchRequest(config) {
    try {
      const configuration = clone(config);
      const concludeRequest = await startRequest(configuration);
      const isCacheEnabled = configuration.cache && configuration.cache.enabled;

      // for some odd reason, result.cache had this weird mutation
      // issue even when CLONING the result, so I had to do this
      // to get it to work properly

      const cache = {
        key: null,
        hit: false,
        pulled: false,
        stored: false
      };
      if (isCacheEnabled) {
        const cacheKey = this.$cache.getCacheKey(configuration.url.href);
        const entity = this.$cache.get(cacheKey, true);
        cache.hit = true;
        if (entity) {
          const result = await concludeRequest({
            data: entity.v
          });
          cache.key = cacheKey;
          cache.pulled = true;
          result.cache = cache;
          return Promise.resolve(result);
        }
      }
      const response = await this.$api.send(configuration);
      const result = await concludeRequest(response);
      if (isCacheEnabled) {
        this.$cache.set(configuration.url.href, response.data);
        cache.key = this.$cache.getCacheKey(configuration.url.href);
        cache.stored = true;
      }
      result.cache = cache;
      return Promise.resolve(result);
    } catch (error) {
      return Promise.reject(new UrbexError(error));
    }
  }
}

function debug(type, message) {
  console[type](`[urbex] ${message}`);
}

function parseHeaderKey(key) {
  if (key) {
    return formatHeaderKey(key.toLowerCase()).trim();
  }
  return undefined;
}
function parseHeaderValue(value) {
  if (isUndefined(value) || value === false || value === null) {
    return undefined;
  }
  if (isArray(value)) {
    return value.join(", ");
  }
  if (isObject(value)) {
    return JSON.stringify(value);
  }
  return String(value);
}
function normalizeHeaders(headers) {
  const newHeaders = {};
  forEach(headers, (key, value) => {
    if (isUndefined(key) || isUndefined(value)) {
      return;
    }
    const normalizedKey = parseHeaderKey(key);
    const normalizedValue = parseHeaderValue(value);
    if (normalizedKey && normalizedValue) {
      newHeaders[normalizedKey] = normalizedValue;
    }
  });
  return newHeaders;
}
function formatHeaderKey(key) {
  return key.split("-").map(capitalize).join("-");
}
class UrbexHeaders {
  constructor(headers) {
    let withDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    _defineProperty(this, "$headers", {});
    if (withDefaults) {
      this.set(this.defaults, false);
    }
    if (isObject(headers) && !isEmpty(headers)) {
      this.set(headers, withDefaults);
    }
  }
  static construct() {
    let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let withDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return new UrbexHeaders(headers, withDefaults);
  }
  get defaults() {
    return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;
  }

  /**
   * Set a header configuration to use for all requests made by the current
   * instance of the Urbex client
   *
   * Setting a configuration will merge with any existing configuration.
   * Optionally, you can pass a boolean to clear the existing configuration
   *
   * @param headers The headers to set
   * @param forceMerge Whether to merge the headers with the existing configuration
   */
  set(headers) {
    let forceMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!isObject(headers)) {
      debug("error", `Attempted to set headers with a non-object value: ${typeof headers}`);
      return headers;
    }
    const normalizedHeaders = this.normalize(headers);
    const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;
    return this.$headers = merged;
  }
  /**
   * Get the current headers object
   */
  get() {
    return this.$headers;
  }

  /**
   * Whether the headers object contains a given header
   */
  has(key) {
    return hasOwnProperty(this.$headers, key);
  }

  /**
   * Delete a header from the headers object
   */
  delete(key) {
    forEach(this.$headers, headerKey => {
      if (headerKey.toLowerCase() === key.toLowerCase()) {
        delete this.$headers[headerKey];
      }
    });
  }
  /**
   *
   * Clear all headers that have been set
   * @param empty Whether to empty the headers object
   *
   */
  clear() {
    let empty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    this.$headers = {};
    if (!empty) {
      this.set(this.defaults, false);
    }
  }

  /**
   * Normalize an incoming headers object
   */

  normalize(headers) {
    if (argumentIsNotProvided(headers) || !isObject(headers)) {
      return {};
    }
    return normalizeHeaders(headers);
  }
}

class PipelineExecutor {
  constructor(executor) {
    _defineProperty(this, "$executor", null);
    this.$executor = executor;
  }
  execute(config) {
    return this.$executor(config);
  }
}

const transformRequestData = new PipelineExecutor(config => {
  return Promise.resolve(config);
});
const decodeResponseData = new PipelineExecutor(async response => {
  const responseType = response.config.responseType;
  if (responseType === "raw" || responseType === "stream") {
    return Promise.resolve(response);
  }
  const encoding = response.headers["content-encoding"];
  if (Buffer.isBuffer(response.data) && response.data.length) {
    if (encoding) {
      const decoder = DECODERS[encoding];
      if (decoder) {
        const decompressed = await decoder(response.data);
        const maxContentLength = response.config.maxContentLength;
        if (maxContentLength > -1 || maxContentLength !== Infinity) {
          if (decompressed.length > maxContentLength) {
            throw new Error(`Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`);
          }
        }
        response.data = decompressed;
      }
    }
  } else {
    response.data = null;
  }
  return Promise.resolve(response);
});
const transformResponseData = new PipelineExecutor(response => {
  const responseType = response.config.responseType;
  if (responseType === "raw" || responseType === "arraybuffer" || responseType === "stream") {
    return Promise.resolve(response);
  }
  if (response.data) {
    // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows

    const {
      responseEncoding,
      responseType
    } = response.config;
    const bufferString = response.data.toString(responseEncoding);
    if (responseType === "json") {
      response.data = JSON.parse(bufferString);
    } else {
      response.data = bufferString;
    }
  }
  return Promise.resolve(response);
});

// support for any protocols to be used with the uri component
// currently only http and https are supported

// regex to get the protocol from the uri component, can match anything
const PROTOCOL_REGEXP = /^([a-z0-9]+):\/\//i;
const URI_TEMPLATE_REGEXP_LEFT = "[{][^{{]*\\b";
const URI_TEMPLATE_REGEXP_RIGHT = "\\b[^{}]*[}]";
const METHODS = ["PUT", "POST", "PATCH", "OPTIONS", "HEAD", "GET", "DELETE"];

/**
 * Test if a url is valid
 */
function isValidURL(url) {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
}
function convertStringToURIComponent(input) {
  let urlMount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  const url = new URL(input);
  const protocol = stringReplacer(url.protocol, ":", "");
  const port = url.port ? parseInt(url.port) : "";
  const pathname = stringReplacer(url.pathname, urlMount, "");
  return {
    href: url.href,
    origin: url.origin,
    protocol: protocol,
    hostname: url.hostname,
    port: port,
    endpoint: pathname,
    params: url.search,
    urlMount: urlMount
  };
}

// turn this into its own package
function convertURIComponentToString(input) {
  let template = "{protocol+://}{hostname}{:+port}{urlMount}{endpoint}{?+params}";
  function createRegexString(word) {
    return new RegExp(`${URI_TEMPLATE_REGEXP_LEFT}${word}${URI_TEMPLATE_REGEXP_RIGHT}`, "gi");
  }
  if (argumentIsNotProvided(input) || isEmpty(input) || !isObject(input)) {
    return "";
  }
  if (input.params) {
    input.params = serializeParams(input.params);
  }
  forEach(input, (key, value) => {
    const regex = createRegexString(key);
    if (argumentIsNotProvided(value) || isEmpty(value)) {
      template = stringReplacer(template, regex, "");
    } else {
      const match = extractMatchFromRegExp(template, regex, 0, "");
      const templateValue = stringReplacer(match, key, value.toString()).replace(/\+/g, "").replace(/^\{/, "").replace(/\}$/, "");
      template = stringReplacer(template, match, templateValue);
    }
  });
  return template;
}
function parseURIIntoComponent(component) {
  let allowEndpoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (isString(component)) {
    if (isValidURL(component)) {
      return convertStringToURIComponent(component);
    } else if (allowEndpoints) {
      return {
        endpoint: ensureLeadingToken("/", component)
      };
    } else {
      throw new Error("An invalid URL was provided. A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.");
    }
  } else if (isObject(component)) {
    const protocol = extractMatchFromRegExp(component.protocol, PROTOCOL_REGEXP, 0, "http");
    const hostname = stringReplacer(component.hostname, new RegExp(`^${protocol}://`, "gi"), "");
    const endpoint = ensureLeadingToken("/", component.endpoint);
    const urlMount = ensureLeadingToken("/", component.urlMount);
    const buildableComponent = merge(component, {
      protocol: protocol,
      hostname: hostname,
      endpoint: endpoint,
      urlMount: urlMount
    });
    const componentAsString = convertURIComponentToString(buildableComponent);
    const newComponent = convertStringToURIComponent(componentAsString, urlMount);
    return newComponent;
  } else {
    throw new Error("Unable to parse the provided URI. Must be either a string or an object.");
  }
}
function serializeParams(params) {
  let serializerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "string";
  if (argumentIsNotProvided(params)) {
    return null;
  }
  try {
    const searchParams = new URLSearchParams(params);
    if (serializerType === "object") {
      const params = {};
      searchParams.forEach((value, key) => {
        params[key] = value;
      });
      return params;
    }
    return searchParams.toString();
  } catch (error) {
    return null;
  }
}

function determineAppropriateURI() {
  const component = merge(DEFAULT_URI_COMPONENT, {
    protocol: "https",
    urlMount: "/api"
  });
  if (environment.isBrowser) {
    const {
      protocol,
      hostname,
      port
    } = window.location;
    Object.assign(component, {
      protocol: protocol.replace(":", ""),
      hostname: hostname,
      port: port
    });
  } else if (environment.isNode) {
    Object.assign(component, {
      protocol: "http",
      hostname: "localhost",
      port: 3000
    });
  }
  return component;
}
class RequestConfig {
  constructor(config) {
    const component = parseURIIntoComponent(determineAppropriateURI());
    this.$config = merge(DEFAULT_CLIENT_OPTIONS, {
      url: component,
      headers: new UrbexHeaders()
    });
    if (isObject(config) && !isEmpty(config)) {
      this.set(this.createConfigurationObject(config, true));
    }
    this.$config.pipelines.request.unshift(transformRequestData);
    if (environment.isNode) {
      this.$config.pipelines.response.unshift(decodeResponseData, transformResponseData);
    }
  }
  defaultConfig() {
    return merge(DEFAULT_CLIENT_OPTIONS, {
      url: parseURIIntoComponent(determineAppropriateURI()),
      headers: new UrbexHeaders()
    });
  }
  createConfigurationObject(config, allowEndpoints) {
    const parsed = this.parseIncomingConfig(config, allowEndpoints);
    const merged = this.merge(parsed);
    return merged;
  }
  parseIncomingConfig(config, allowEndpoints) {
    var _configuration$timeou, _configuration$timeou2, _configuration$maxCon, _configuration$maxCon2;
    if (argumentIsNotProvided(config) || !isObject(config)) {
      throw new Error("The configuration must be an object with valid properties.");
    }
    const configuration = clone(config);
    if (hasOwnProperty(configuration, "url")) {
      const currentUrlConfig = this.get().url;
      if (isObject(configuration.url)) {
        // have to merge otherwise the uri parser may
        // throw an error if fewer values are provided
        configuration.url = merge(currentUrlConfig, configuration.url);
      }
      if (allowEndpoints && configuration.url.toString().startsWith("/")) {
        configuration.url = merge(currentUrlConfig, {
          endpoint: configuration.url
        });
      }
      const parsed = parseURIIntoComponent(configuration.url, allowEndpoints);
      configuration.url = parsed;
    }
    if (hasOwnProperty(configuration, "method")) {
      const method = uppercase(configuration.method);
      if (!METHODS.includes(method)) {
        throw new Error(`The method ${method} is not a valid HTTP method.`);
      }
      configuration.method = method;
    }
    const timeout = parseInt((_configuration$timeou = (_configuration$timeou2 = configuration.timeout) === null || _configuration$timeou2 === void 0 ? void 0 : _configuration$timeou2.toString()) !== null && _configuration$timeou !== void 0 ? _configuration$timeou : DEFAULT_CLIENT_OPTIONS.timeout.toString());
    if (isNaN(timeout)) {
      configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;
    }
    const maxContentLength = parseInt((_configuration$maxCon = (_configuration$maxCon2 = configuration.maxContentLength) === null || _configuration$maxCon2 === void 0 ? void 0 : _configuration$maxCon2.toString()) !== null && _configuration$maxCon !== void 0 ? _configuration$maxCon : DEFAULT_CLIENT_OPTIONS.maxContentLength.toString());
    if (isNaN(maxContentLength)) {
      configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;
    }
    const headers = UrbexHeaders.construct(configuration.headers, true);
    delete configuration.headers;
    return merge(configuration, {
      headers: headers
    });
  }
  set(config) {
    this.$config = config;
    return config;
  }
  merge(config) {
    var _config$headers$get, _config$headers;
    if (argumentIsNotProvided(config) || !isObject(config)) {
      return this.get();
    }
    const currentConfig = this.get();
    const incomingHeaders = (_config$headers$get = (_config$headers = config.headers) === null || _config$headers === void 0 ? void 0 : _config$headers.get()) !== null && _config$headers$get !== void 0 ? _config$headers$get : {};
    const mergedHeaders = merge(currentConfig.headers, incomingHeaders);
    delete config.headers;
    const merged = deepMerge(currentConfig, config);
    const headersObject = UrbexHeaders.construct(mergedHeaders);
    return merge(merged, {
      headers: headersObject
    });
  }
  get() {
    return this.$config;
  }

  /**
   * Reset the configuration to its default state.
   */
  reset() {}
}

function createMethodConfig(method, uri, config) {
  if (argumentIsNotProvided(uri)) {
    throw new Error("Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.");
  }
  return merge(config, {
    url: uri,
    method: method
  });
}
class UrbexClient extends RequestApi {
  constructor(config) {
    super();
    _defineProperty(this, "$pipelines", {
      request: [],
      response: []
    });
    this.$config = new RequestConfig(config);
  }

  /**
   *
   * Creates a new instance of the UrbexClient.
   */
  static create(config) {
    return new UrbexClient(config);
  }

  /**
   * Current, and most up-to-date configuration of the UrbexClient.
   */
  get config() {
    return this.$config.get();
  }

  /**
   * The internal cache module.
   */
  get cache() {
    return this.$cache;
  }

  /**
   * Configures the UrbexClient. You are free to call this method as
   * many times as you want. All configurations will be merged together.
   *
   * @param config The configuration to use.
   */
  configure(config) {
    const configuration = this.$config.createConfigurationObject(config, false);
    this.$config.set(configuration);
    if (isEmpty(configuration.cache)) {
      if (this.$cache) {
        this.$cache.clear();
        if (this.$cache.isRunning) {
          this.$cache.stop();
        }
      }
    } else {
      this.$cache.configure(configuration.cache);
      if (!this.$cache.isRunning) {
        this.$cache.start();
      }
    }
  }
  send() {
    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const configuration = this.$config.parseIncomingConfig(config, true);
    const merged = this.$config.merge(configuration);
    return this.dispatchRequest(merged);
  }

  /**
   * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response
   */
  injectPipeline() {}

  /**
   * Eject a pipeline from the UrbexClient.
   */
  ejectPipeline() {}

  /**
   * When a response is received, the UrbexClient will actively push out the response to all active
   * subscriptions
   */
  subscribe() {}
  unsubscribe() {}
}
forEach(["delete", "get", "head", "options"], (_, value) => {
  UrbexClient.prototype[value] = function (url, config) {
    return this.send(createMethodConfig(uppercase(value), url, config));
  };
});
forEach(["post", "put", "patch"], (_, value) => {
  UrbexClient.prototype[value] = function (url, data, config) {
    function combineIncomingConfig() {
      if (isUndefined(data)) {
        return data;
      }
      if (isObject(config)) {
        return merge(config, {
          data: data
        });
      } else {
        return {
          data
        };
      }
    }
    const configuration = combineIncomingConfig();
    return this.send(createMethodConfig(uppercase(value), url, configuration));
  };
});
function isUrbexClient(client) {
  return client instanceof UrbexClient;
}

function createClient() {
  const client = UrbexClient.create();
  const extendedClient = client;
  extendedClient.isolateClient = UrbexClient.create;
  extendedClient.environment = environment;
  extendedClient.isUrbexClient = isUrbexClient;
  extendedClient.Client = UrbexClient;
  return extendedClient;
}
const urbex = createClient();

export { PipelineExecutor, urbex as default };
//# sourceMappingURL=urbex.min.js.map
