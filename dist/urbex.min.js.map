{"version":3,"file":"urbex.min.js","sources":["../lib/environment.ts","../node_modules/cache-clock/dist/module/index.esm.js","../lib/core/error.ts","../lib/core/api/resolve-request.ts","../lib/utils.ts","../lib/core/api/http.ts","../lib/core/api/xhr.ts","../lib/core/pipelines.ts","../lib/core/constants.ts","../lib/core/headers.ts","../lib/debug.ts","../lib/core/api/request-api.ts","../lib/core/api/conclude.ts","../lib/core/transformers.ts","../lib/constants.ts","../lib/core/url.ts","../lib/core/request-config.ts","../lib/core/urbex.ts","../lib/urbex.ts","../index.ts"],"sourcesContent":["export type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","/**\n    * https://github.com/itsmichaelbtw/cache-clock#readme\n    * (c) 2022 Michael Cizek\n    * @license MIT\n    */\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\nfunction isPureObject(value) {\n  return _typeof(value) === \"object\" && value !== null && !Array.isArray(value);\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNegative(value) {\n  return value < 0;\n}\nfunction absolute(value) {\n  return Math.abs(value);\n}\nfunction shallowMerge(target, source) {\n  return Object.assign({}, target, source);\n}\nfunction stringify(value) {\n  if (isUndefined(value)) {\n    return \"\";\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return JSON.stringify(value);\n}\n\nfunction getCurrentEnvironment() {\n  if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\n    return \"browser\";\n  }\n  if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n    return \"node\";\n  }\n  return \"unknown\";\n}\nvar environment = getCurrentEnvironment();\n\nvar colors = {\n  red: \"\\x1b[31m\",\n  yellow: \"\\x1b[33m\",\n  green: \"\\x1b[32m\",\n  lightblue: \"\\x1b[36m\"\n};\nvar globals = {\n  reset: \"\\x1b[0m\",\n  bright: \"\\x1b[1m\"\n};\nfunction debug(message, color) {\n  if (debug.DEBUG) {\n    var prefix = \"[CACHE-CLOCK] \";\n    var colorizedMessage = \"\".concat(colors[color]).concat(prefix).concat(message).concat(globals.reset);\n    console.log(colorizedMessage);\n  }\n}\ndebug.DEBUG = false;\n\nfunction hash(input) {\n  if (typeof input !== \"string\") {\n    input = JSON.stringify(input);\n  }\n  var numberHash = input.split(\"\").reduce(function (a, b) {\n    a = (a << 5) - a + a * 24 + b.charCodeAt(0);\n    a |= 0;\n    return a;\n  }, 0);\n  return numberHash.toString(32);\n}\n\nfunction getBestTimeProvider() {\n  try {\n    // future: use either perf_hooks for node js or performance for browser\n    // fallback on Date.now() for now\n    return Date;\n  } catch (error) {\n    return Date;\n  }\n}\nvar timeProvider = getBestTimeProvider();\n\nvar _Symbol$iterator;\nvar DEFAULT_CLOCK_OPTIONS = {\n  maxItems: 1000,\n  ttl: Infinity,\n  interval: 15 * 1000,\n  debug: false,\n  autoStart: true,\n  overwrite: false,\n  resetTimeoutOnAccess: false\n};\nfunction invokeTimeout(callback, delay) {\n  var timeout = environment === \"node\" ? global.setTimeout : window.setTimeout;\n  return timeout.call(null, callback, delay);\n}\nfunction parseCacheOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultOptions = arguments.length > 1 ? arguments[1] : undefined;\n  if (!isPureObject(options)) {\n    debug(\"Invalid options passed to cache clock, using defaults.\", \"yellow\");\n    return defaultOptions;\n  }\n  var opts = shallowMerge(defaultOptions, options);\n  if (isNumber(opts.maxItems) && isNegative(opts.maxItems)) {\n    opts.maxItems = absolute(opts.maxItems);\n  } else if (!isNumber(opts.maxItems)) {\n    opts.maxItems = defaultOptions.maxItems;\n  }\n  if (isNumber(opts.ttl) && isNegative(opts.ttl)) {\n    opts.ttl = absolute(opts.ttl);\n  } else if (!isNumber(opts.maxItems)) {\n    opts.ttl = defaultOptions.ttl;\n  }\n  if (isNumber(opts.interval) && isNegative(opts.interval)) {\n    opts.interval = absolute(opts.interval);\n  } else if (!isNumber(opts.interval)) {\n    opts.interval = defaultOptions.interval;\n  }\n  if (opts.onExpire && !isFunction(opts.onExpire)) {\n    opts.onExpire = undefined;\n  }\n  if (opts.maxItems === 0) {\n    opts.maxItems = 1;\n  }\n  return opts;\n}\nfunction createEntityKey(key, isHashed) {\n  if (isHashed) {\n    return key;\n  }\n  return hash(stringify(key));\n}\n_Symbol$iterator = Symbol.iterator;\nvar CacheClock = /*#__PURE__*/function () {\n  /**\n   * Create a new instance of the cache clock. You can\n   * pass a configuration object to set the default\n   * options for all cacheable items.\n   *\n   * ```js\n   * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });\n   * ```\n   */\n  function CacheClock(options) {\n    _classCallCheck(this, CacheClock);\n    _defineProperty(this, \"$birth\", void 0);\n    _defineProperty(this, \"$cache\", void 0);\n    _defineProperty(this, \"$clock\", void 0);\n    _defineProperty(this, \"$options\", void 0);\n    this.$birth = timeProvider.now();\n    this.$cache = new Map();\n    this.configure(options);\n    if (this.options.autoStart) {\n      this.start();\n    }\n  }\n  _createClass(CacheClock, [{\n    key: \"prune\",\n    value: function prune() {\n      this.stop();\n      var now = timeProvider.now();\n      var _iterator = _createForOfIteratorHelper(this),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n          if (value.e <= now) {\n            var _entry = this.del(value.k, true);\n            if (this.options.onExpire && _entry) {\n              this.options.onExpire(_entry);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.start();\n    }\n\n    /**\n     * Create a new instance of the cache clock. You can\n     * pass a configuration object to set the default\n     * options for all cacheable items.\n     *\n     * ```js\n     * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });\n     * ```\n     */\n  }, {\n    key: \"age\",\n    get:\n    /**\n     * The age of the cache clock in `ms`.\n     */\n    function get() {\n      return timeProvider.now() - this.$birth;\n    }\n\n    /**\n     * The number of items in the cache.\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.$cache.size;\n    }\n\n    /**\n     * Global configuration that applies to all cacheable items.\n     */\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this.$options;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n  }, {\n    key: \"isRunning\",\n    get: function get() {\n      return !!this.$clock;\n    }\n\n    /**\n     * Configure the cache clock. Use this method to change the global configuration\n     * that applies to all cacheable items.\n     *\n     * Items that have been cached prior to updating the configuration will not be\n     * affected.\n     *\n     * ```js\n     * const clock = new CacheClock();\n     * clock.configure({ ttl: 5 * 60 * 1000 });\n     * ```\n     */\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.$options = parseCacheOptions(options, this.options || DEFAULT_CLOCK_OPTIONS);\n      debug.DEBUG = this.options.debug;\n      if (this.options.interval < DEFAULT_CLOCK_OPTIONS.interval) {\n        debug(\"A cache clock interval less than 15 seconds is not recommended.\", \"yellow\");\n      }\n    }\n\n    /**\n     * Start the cache clock. This is automatically called when the cache clock is created.\n     * You should only need to call this method if you have stopped the cache clock manually.\n     *\n     * This will spawn a new clock with the full timeout interval. This does not resume the\n     * clock from where it left off.\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.options.interval === Infinity || this.options.interval === 0) {\n        debug(\"Disabling the clock due to an unsupported interval.\", \"yellow\");\n        return;\n      }\n      if (this.$clock) {\n        debug(\"Cache clock is already running. Unable to start.\", \"red\");\n        return;\n      }\n      this.$clock = invokeTimeout(this.prune.bind(this), this.options.interval);\n    }\n\n    /**\n     * Manually stop the cache clock. This will disable the automatic expiration of items. This does\n     * not prevent items from being checked for expiration.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.$clock) {\n        debug(\"Cache clock is not running. Unable to stop.\", \"red\");\n        return;\n      }\n      clearTimeout(this.$clock);\n      this.$clock = null;\n    }\n\n    /**\n     * Add an item to the cache. Optionally, you can specify a time to live for the item.\n     *\n     * If the cache is full, the oldest item will be removed.\n     */\n  }, {\n    key: \"set\",\n    value: function set(key, value, options) {\n      var hashedKey = createEntityKey(key, false);\n      var _parseCacheOptions = parseCacheOptions(options, this.options),\n        ttl = _parseCacheOptions.ttl,\n        overwrite = _parseCacheOptions.overwrite;\n      var clockItem = {\n        k: hashedKey,\n        v: value,\n        t: ttl,\n        e: timeProvider.now() + ttl\n      };\n      var existingEntry = this.get(hashedKey, true);\n      if (existingEntry) {\n        if (overwrite) {\n          debug(\"Overwriting existing cache entry for key \\\"\".concat(hashedKey, \"\\\".\"), \"yellow\");\n          this.del(hashedKey, true);\n        } else {\n          debug(\"Unable to set cache item \\\"\".concat(hashedKey, \"\\\". The item already exists.\"), \"red\");\n          return existingEntry;\n        }\n      }\n      if (this.size >= this.options.maxItems) {\n        debug(\"The cache is full, removing oldest item.\", \"yellow\");\n        this.del(this.$cache.keys().next().value, true);\n      }\n      this.$cache.set(hashedKey, clockItem);\n      return clockItem;\n    }\n\n    /**\n     * Retrieve an item from the cache. This returns the internal\n     * `CacheEntry` used to store the value.\n     */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var item = this.$cache.get(hashedKey);\n      if (isUndefined(item)) {\n        return undefined;\n      }\n      var now = timeProvider.now();\n      if (item.e < now) {\n        debug(\"Cache item \".concat(key, \" has expired.\"), \"red\");\n        this.del(hashedKey, true);\n        return undefined;\n      }\n      if (this.options.resetTimeoutOnAccess) {\n        item.e = now + item.t;\n      }\n      return item;\n    }\n\n    /**\n     * Deletes an item from the cache. Returns the deleted item\n     * if it exists.\n     */\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var item = this.$cache.get(hashedKey);\n      if (isUndefined(item)) {\n        return undefined;\n      }\n      debug(\"Deleting cache item \".concat(key, \".\"), \"green\");\n      this.$cache[\"delete\"](hashedKey);\n      return item;\n    }\n\n    /**\n     * Returns a boolean indicating whether the cache contains an item.\n     */\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var entry = this.get(hashedKey, true);\n      return !isUndefined(entry);\n    }\n\n    /**\n     * Wipe the cache clean.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.$cache.clear();\n    }\n\n    /**\n     * Create a cache key based on the input.\n     */\n  }, {\n    key: \"getCacheKey\",\n    value: function getCacheKey(input) {\n      return createEntityKey(input, false);\n    }\n\n    /**\n     * Returns a JSON representation of the cache.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Array.from(this.$cache.values());\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.$cache.values();\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new CacheClock(options);\n    }\n  }]);\n  return CacheClock;\n}();\n\nexport { CacheClock };\n//# sourceMappingURL=index.esm.js.map\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\nexport class TimeoutError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = \"The request timed out.\";\r\n    }\r\n\r\n    public set timeout(timeout: number) {\r\n        this.message = `Timeout of ${timeout}ms exceeded`;\r\n    }\r\n}\r\n\r\nexport class NetworkError extends UrbexError {\r\n    constructor() {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = \"Failed to request the resource.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: any\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n    const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n    if (canResolve) {\r\n        return resolve(entity);\r\n    }\r\n\r\n    const error: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n    const errorMessage = `Request failed with status code ${status}`;\r\n\r\n    error.message = environment.isNode\r\n        ? entity.response.statusMessage\r\n        : entity.response.statusText ?? errorMessage;\r\n    error.request = this.request;\r\n    error.status = status;\r\n    error.response = entity.response;\r\n\r\n    return reject(error);\r\n}\r\n","import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(defaultOptions: P, options: T): P & T {\r\n    return Object.assign({}, defaultOptions, options);\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combinedStringss(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[]): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = null;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { Socket } from \"net\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi, DispatchedAPIRequest } from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combinedStringss, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            if (config.url.params && !isString(config.url.params)) {\r\n                config.url.params = config.url.params.toString();\r\n            } else {\r\n                config.url.params = \"\";\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combinedStringss(\"\", config.url.endpoint, config.url.params),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                const port = parseInt(config.url.port.toString());\r\n\r\n                if (!isNaN(port)) {\r\n                    options.port = port;\r\n                }\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError);\r\n                errorInstance.message = error.message;\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: any): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T\r\n            ): InstanceType<T> {\r\n                return UrbexError.createErrorInstance.call({ config, request }, instance);\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const timeoutError = createErrorInstance(TimeoutError);\r\n                timeoutError.timeout = config.timeout;\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(UrbexError);\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError);\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject } from \"../utils\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult) || argumentIsNotProvided(pipelineResult)) {\r\n                throw new Error(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public execute(config: Parameters<T>): ReturnType<T> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { InternalConfiguration, URIComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { environment } from \"../environment\";\r\nimport { merge, createEmptyScheme } from \"../utils\";\r\n\r\nexport const DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nexport const DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const DEFAULT_URI_COMPONENT = createEmptyScheme<URIComponent>([\r\n    \"endpoint\",\r\n    \"hostname\",\r\n    \"href\",\r\n    \"origin\",\r\n    \"params\",\r\n    \"port\",\r\n    \"protocol\",\r\n    \"urlMount\"\r\n]);\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"http\",\r\n        urlMount: \"/api\"\r\n    }),\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\nimport { DEFAULT_BROWSER_HEADERS, DEFAULT_NODE_HEADERS } from \"./constants\";\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { UrbexHeaders } from \"../headers\";\r\nimport { clone, deepClone, isUndefined } from \"../../utils\";\r\n\r\n// here all of the interceptors are checked\r\n// cache clocks are checked here\r\n// the response is created here\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = deepClone(config);\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            // for some odd reason, result.cache had this weird mutation\r\n            // issue even when CLONING the result, so I had to do this\r\n            // to get it to work properly\r\n\r\n            // solved: the clone function that is internally provided\r\n            // only shallow clones the object, so the cache object\r\n            // was being mutated. It is now deep cloned.\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.create(config);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        await PipelineExecutor.process(config, config.pipelines.request);\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        let incomingResult = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            await PipelineExecutor.process(incomingResult, config.pipelines.response);\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { MethodsUpper } from \"./types\";\r\n\r\n// support for any protocols to be used with the uri component\r\n// currently only http and https are supported\r\n\r\n// regex to get the protocol from the uri component, can match anything\r\n// should return http or https\r\nexport const PROTOCOL_REGEXP = /^(?:([a-z]+):\\/\\/)?([^:\\/\\n]+)/i;\r\nexport const HOSTNAME_REGEXP = /^(?:https?:\\/\\/)?(?:[^@\\/\\n]+@)?([^:\\/\\n]+)/i;\r\nexport const PORT_REGEXP = /:(\\d{2,5})$/;\r\n\r\nexport const URL_REGEXP =\r\n    /^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$/i;\r\n\r\nexport const URI_TEMPLATE_REGEXP_LEFT = \"[{][^{{]*\\\\b\";\r\nexport const URI_TEMPLATE_REGEXP_RIGHT = \"\\\\b[^{}]*[}]\";\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { UrbexURL, URIComponent } from \"../exportable-types\";\r\nimport type { SearchParams } from \"../types\";\r\n\r\nimport {\r\n    URL_REGEXP,\r\n    HOSTNAME_REGEXP,\r\n    PROTOCOL_REGEXP,\r\n    URI_TEMPLATE_REGEXP_LEFT,\r\n    URI_TEMPLATE_REGEXP_RIGHT\r\n} from \"../constants\";\r\nimport {\r\n    isObject,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    ensureLeadingToken,\r\n    stringReplacer,\r\n    argumentIsNotProvided,\r\n    combinedStringss,\r\n    forEach,\r\n    merge,\r\n    isFunction,\r\n    isEmpty\r\n} from \"../utils\";\r\nimport { DEFAULT_URI_COMPONENT } from \"./constants\";\r\n\r\nexport type ParamSerializerType = \"string\" | \"object\" | \"URLSearchParams\";\r\n\r\n/**\r\n * Test if a url string has a valid protocol.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isProtocolURL(url: string): boolean {\r\n    return PROTOCOL_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url string has a valid hostname.\r\n *\r\n * Most likely going to deprecate this function.\r\n */\r\nexport function isHostnameURL(url: string): boolean {\r\n    return HOSTNAME_REGEXP.test(url);\r\n}\r\n\r\n/**\r\n * Test if a url is valid\r\n */\r\nexport function isValidURL(url: string): boolean {\r\n    try {\r\n        new URL(url);\r\n\r\n        return true;\r\n    } catch (error) {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function convertStringToURIComponent(input: string, urlMount = \"\"): URIComponent {\r\n    const url = new URL(input);\r\n\r\n    const protocol = stringReplacer(url.protocol, \":\", \"\") as string;\r\n    const port = url.port ? parseInt(url.port) : \"\";\r\n    const pathname = stringReplacer(url.pathname, urlMount, \"\");\r\n\r\n    return {\r\n        href: url.href,\r\n        origin: url.origin,\r\n        protocol: protocol,\r\n        hostname: url.hostname,\r\n        port: port,\r\n        endpoint: pathname,\r\n        params: url.search,\r\n        urlMount: urlMount\r\n    };\r\n}\r\n\r\n// turn this into its own package\r\nexport function convertURIComponentToString(input: Partial<URIComponent>): string {\r\n    let template = \"{protocol+://}{hostname}{:+port}{urlMount}{endpoint}{?+params}\";\r\n\r\n    function createRegexString(word: string): RegExp {\r\n        return new RegExp(`${URI_TEMPLATE_REGEXP_LEFT}${word}${URI_TEMPLATE_REGEXP_RIGHT}`, \"gi\");\r\n    }\r\n\r\n    if (argumentIsNotProvided(input) || isEmpty(input) || !isObject(input)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (input.params) {\r\n        input.params = serializeParams(input.params);\r\n    }\r\n\r\n    forEach(input, (key, value) => {\r\n        const regex = createRegexString(key);\r\n\r\n        if (argumentIsNotProvided(value) || isEmpty(value)) {\r\n            template = stringReplacer(template, regex, \"\");\r\n        } else {\r\n            const match = extractMatchFromRegExp(template, regex, 0, \"\");\r\n            const templateValue = stringReplacer(match, key, value.toString())\r\n                .replace(/\\+/g, \"\")\r\n                .replace(/^\\{/, \"\")\r\n                .replace(/\\}$/, \"\");\r\n\r\n            template = stringReplacer(template, match, templateValue);\r\n        }\r\n    });\r\n\r\n    return template;\r\n}\r\n\r\nexport function parseURIIntoComponent(\r\n    component: UrbexURL,\r\n    allowEndpoints = true\r\n): Partial<URIComponent> {\r\n    if (isString(component)) {\r\n        if (isValidURL(component)) {\r\n            return convertStringToURIComponent(component);\r\n        } else if (allowEndpoints) {\r\n            return {\r\n                endpoint: ensureLeadingToken(\"/\", component)\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                \"An invalid URL was provided. A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n            );\r\n        }\r\n    } else if (isObject(component)) {\r\n        const protocol = extractMatchFromRegExp(component.protocol, PROTOCOL_REGEXP, 0, \"http\");\r\n        const hostname = stringReplacer(\r\n            component.hostname,\r\n            new RegExp(`^${protocol}://`, \"gi\"),\r\n            \"\"\r\n        );\r\n\r\n        const endpoint = ensureLeadingToken(\"/\", component.endpoint);\r\n        const urlMount = ensureLeadingToken(\"/\", component.urlMount);\r\n\r\n        const buildableComponent = merge(component, {\r\n            protocol: protocol,\r\n            hostname: hostname,\r\n            endpoint: endpoint,\r\n            urlMount: urlMount\r\n        });\r\n\r\n        const componentAsString = convertURIComponentToString(buildableComponent);\r\n        const newComponent = convertStringToURIComponent(componentAsString, urlMount);\r\n\r\n        return newComponent;\r\n    } else {\r\n        throw new Error(\"Unable to parse the provided URI. Must be either a string or an object.\");\r\n    }\r\n}\r\n\r\nexport function serializeParams(\r\n    params: SearchParams,\r\n    serializerType: ParamSerializerType = \"string\"\r\n): Record<string, string> | string {\r\n    if (argumentIsNotProvided(params)) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const searchParams = new URLSearchParams(params);\r\n\r\n        if (serializerType === \"object\") {\r\n            const params = {};\r\n\r\n            searchParams.forEach((value, key) => {\r\n                params[key] = value;\r\n            });\r\n\r\n            return params;\r\n        }\r\n\r\n        return searchParams.toString();\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n","import type { InternalConfiguration, UrbexConfig, URIComponent } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { isValidURL, serializeParams, parseURIIntoComponent } from \"./url\";\r\nimport { PROTOCOL_REGEXP, HOSTNAME_REGEXP, METHODS } from \"../constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URI_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction determineAppropriateURI(): URIComponent {\r\n    const component = merge(DEFAULT_URI_COMPONENT, {\r\n        protocol: \"https\",\r\n        urlMount: \"/api\"\r\n    });\r\n\r\n    if (environment.isBrowser) {\r\n        const { protocol, hostname, port } = window.location;\r\n\r\n        Object.assign(component, {\r\n            protocol: protocol.replace(\":\", \"\"),\r\n            hostname: hostname,\r\n            port: port\r\n        });\r\n    } else if (environment.isNode) {\r\n        Object.assign(component, {\r\n            protocol: \"http\",\r\n            hostname: \"localhost\",\r\n            port: 3000\r\n        });\r\n    }\r\n\r\n    return component;\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const component = parseURIIntoComponent(determineAppropriateURI());\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const configuration = deepMerge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: component,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: parseURIIntoComponent(determineAppropriateURI()),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        const configuration = clone(config);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const currentUrlConfig = this.get().url;\r\n\r\n            if (isObject(configuration.url)) {\r\n                // have to merge otherwise the uri parser may\r\n                // throw an error if fewer values are provided\r\n                configuration.url = merge(currentUrlConfig, configuration.url);\r\n            }\r\n\r\n            if (allowEndpoints && configuration.url.toString().startsWith(\"/\")) {\r\n                configuration.url = merge(currentUrlConfig, {\r\n                    endpoint: configuration.url\r\n                });\r\n            }\r\n\r\n            const parsed = parseURIIntoComponent(configuration.url, allowEndpoints);\r\n            configuration.url = parsed;\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(\r\n            configuration.timeout?.toString() ?? DEFAULT_CLIENT_OPTIONS.timeout.toString()\r\n        );\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(\r\n            configuration.maxContentLength?.toString() ??\r\n                DEFAULT_CLIENT_OPTIONS.maxContentLength.toString()\r\n        );\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n        delete configuration.headers;\r\n\r\n        return merge<UrbexConfig>(configuration, {\r\n            headers: headers\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers, incomingHeaders);\r\n\r\n        delete config.headers;\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n\r\n        return merge(merged, { headers: headersObject });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (url: UrbexURL, config?: UrbexMethodRequest) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n\r\nexport default urbex;\r\n","import urbex, { PipelineExecutor } from \"./lib/urbex\";\r\n\r\n// since this package has a named export and a default export, rollup\r\n// uses `output.exports: \"named\"` to make the named export the default\r\n// this works for CJS and ESM builds, but not for UMD\r\n\r\n// UMD exports the default export as a named and I don't want that\r\n// by design so I have to use `output.exports: \"default\"`, but\r\n// rollup complains of the 2 export types. So instead this\r\n// file is used to combined all the exports into a single default export\r\n// compatible for browser consumption\r\n\r\ndeclare module \"./lib/urbex\" {\r\n    interface ExtendedUrbexClient {\r\n        PipelineExecutor: typeof PipelineExecutor;\r\n    }\r\n}\r\n\r\nurbex.PipelineExecutor = PipelineExecutor;\r\n\r\nexport default urbex;\r\n"],"names":["environment","constructor","this","_context","detectContext","window","document","process","versions","node","Error","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","_typeof","obj","Symbol","iterator","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_defineProperty","value","_arrayLikeToArray","arr","len","arr2","Array","isUndefined","isPureObject","isArray","isNumber","isNaN","isFunction","isNegative","absolute","Math","abs","shallowMerge","source","assign","colors","red","yellow","green","lightblue","debug","message","color","DEBUG","colorizedMessage","concat","console","log","_Symbol$iterator","timeProvider","Date","error","getBestTimeProvider","DEFAULT_CLOCK_OPTIONS","maxItems","ttl","Infinity","interval","autoStart","overwrite","resetTimeoutOnAccess","parseCacheOptions","options","arguments","undefined","defaultOptions","opts","onExpire","createEntityKey","isHashed","input","isString","JSON","stringify","split","reduce","a","b","charCodeAt","toString","CacheClock","instance","Constructor","TypeError","_classCallCheck","$birth","now","$cache","Map","configure","start","protoProps","staticProps","stop","_step","_iterator","o","allowArrayLike","it","minLen","n","call","slice","name","from","test","_unsupportedIterableToArray","F","s","done","e","f","err","normalCompletion","didErr","step","next","return","_createForOfIteratorHelper","_entry","del","k","get","size","$options","$clock","callback","delay","prune","bind","global","setTimeout","clearTimeout","hashedKey","_parseCacheOptions","clockItem","v","t","existingEntry","keys","set","item","entry","clear","values","UrbexError","static","config","create","request","TimeoutError","super","timeout","NetworkError","resolveRequest","resolve","reject","entity","_entity$response$stat","status","response","statusCode","resolveStatus","createErrorInstance","errorMessage","statusMessage","statusText","hasOwnProperty","prop","isObject","isEmpty","uppercase","String","toUpperCase","deepClone","map","clone","merge","deepMerge","_len","objects","_key","acc","forEach","fn","index","extractMatchFromRegExp","regexp","group","defaultValue","matches","exec","stringReplacer","search","replace","ensureLeadingToken","token","argumentIsNotProvided","startsWith","combinedStringss","delimiter","_len2","strings","_key2","filter","string","join","createEmptyScheme","object","nestedKeys","nestedObject","NodeRequest","getAgentFromProtocol","protocol","https","http","handleDataProtocolRequest","Promise","data","async","_resolve","_reject","_config$data","agent","url","headers","has","params","endsWith","href","hostname","path","endpoint","port","parseInt","onData","push","onError","errorInstance","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","responseType","chunks","chunk","timeoutError","end","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","method","event","listener","open","includes","delete","setRequestHeader","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","executor","$executor","pipelines","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","REQUEST_BODY_METHODS","DEFAULT_URI_COMPONENT","DEFAULT_PIPELINE_EXECUTORS","DEFAULT_CLIENT_OPTIONS","urlMount","cache","maxContentLength","responseEncoding","DEFAULT_URBEX_RESPONSE","removeNewLines","parseHeaderKey","format","word","parsedWord","trim","charAt","capitalize","formatHeaderKey","toLowerCase","parseHeaderValue","UrbexHeaders","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","normalizedHeaders","normalize","merged","$headers","headerKey","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$api","configuration","concludeRequest","startTime","timestamp","toISOString","clonedResponse","result","incomingResult","hit","parse","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","pulled","stored","isInstance","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","PROTOCOL_REGEXP","METHODS","isValidURL","URL","convertStringToURIComponent","pathname","origin","convertURIComponentToString","template","serializerType","searchParams","URLSearchParams","serializeParams","regex","RegExp","match","templateValue","parseURIIntoComponent","component","allowEndpoints","determineAppropriateURI","location","RequestConfig","setup","createConfigurationObject","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$timeou2","_configuration$maxCon","_configuration$maxCon2","currentUrlConfig","construct","$config","_config$headers$get","_config$headers","currentConfig","incomingHeaders","mergedHeaders","reset","createMethodConfig","uri","UrbexClient","stopCache","isRunning","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","_","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}