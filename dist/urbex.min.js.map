{"version":3,"file":"urbex.min.js","sources":["../lib/utils.ts","../lib/core/constants.ts","../lib/core/parsers/base-url-parser.ts","../lib/core/parsers/url-parser.ts","../lib/environment.ts","../node_modules/cache-clock/dist/module/index.esm.js","../lib/core/error.ts","../lib/core/api/resolve-request.ts","../lib/core/api/http.ts","../lib/core/api/xhr.ts","../lib/core/pipelines.ts","../lib/core/headers.ts","../lib/debug.ts","../lib/core/api/request-api.ts","../lib/core/api/conclude.ts","../lib/core/transformers.ts","../lib/core/request-config.ts","../lib/core/urbex.ts","../lib/urbex.ts","../index.ts"],"sourcesContent":["import type { IObject } from \"./types\";\r\n\r\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\r\n    ? I\r\n    : never;\r\n\r\n/**\r\n * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.\r\n */\r\nexport function toStringCall(value: any): string {\r\n    const string = Object.prototype.toString.call(value);\r\n    return lowercase(string.substring(8, string.length - 1));\r\n}\r\n\r\nexport function hasOwnProperty<X extends {}, Y extends PropertyKey>(\r\n    obj: X,\r\n    prop: Y\r\n): obj is X & Record<Y, unknown> {\r\n    return obj.hasOwnProperty.call(obj, prop);\r\n}\r\n\r\nexport function isUndefined(value: unknown): value is undefined {\r\n    return typeof value === \"undefined\";\r\n}\r\n\r\nexport function isNegative(value: number): boolean {\r\n    return value < 0;\r\n}\r\n\r\nexport function isPositive(value: number): boolean {\r\n    return value > 0;\r\n}\r\n\r\nexport function absolute(value: number): number {\r\n    return Math.abs(value);\r\n}\r\n\r\nexport function round(value: number, precision: number): number {\r\n    const multiplier = Math.pow(10, precision);\r\n    return Math.round(value * multiplier) / multiplier;\r\n}\r\n\r\nexport function isArray<T>(value: unknown): value is T[] {\r\n    return Array.isArray(value);\r\n}\r\n\r\nexport function isObject(value: unknown): value is object {\r\n    return typeof value === \"object\" && value !== null && !isArray(value);\r\n}\r\n\r\nexport function isString(value: unknown): value is string {\r\n    return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: unknown): value is Function {\r\n    return typeof value === \"function\";\r\n}\r\n\r\nexport function isNumber(value: unknown): value is number {\r\n    return typeof value === \"number\";\r\n}\r\n\r\nexport function isEmpty(value: any): boolean {\r\n    if (isArray(value)) {\r\n        return value.length === 0;\r\n    } else if (isObject(value)) {\r\n        return Object.keys(value).length === 0;\r\n    } else {\r\n        return !value;\r\n    }\r\n}\r\n\r\nexport function capitalize(value: string): string {\r\n    value = String(value);\r\n\r\n    if (value.length === 1) {\r\n        return value.toUpperCase();\r\n    } else {\r\n        return value.charAt(0).toUpperCase() + value.slice(1);\r\n    }\r\n}\r\n\r\nexport function uppercase<T extends string>(value: T): T {\r\n    return String(value).toUpperCase() as T;\r\n}\r\n\r\nexport function lowercase(value: string): string {\r\n    return String(value).toLowerCase();\r\n}\r\n\r\nexport function clone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.slice() as unknown as T;\r\n    } else if (isObject(value)) {\r\n        return Object.assign({}, value) as T;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function deepClone<T>(value: T): T {\r\n    if (isArray(value)) {\r\n        return value.map(deepClone) as unknown as T;\r\n    } else if (isObject(value) && value.constructor === Object) {\r\n        const clone = {} as T;\r\n\r\n        for (const key in value) {\r\n            if (hasOwnProperty(value, key)) {\r\n                clone[key] = deepClone(value[key]);\r\n            }\r\n        }\r\n\r\n        return clone;\r\n    } else {\r\n        return value;\r\n    }\r\n}\r\n\r\nexport function merge<P = any, T = any>(\r\n    defaultOptions: P,\r\n    options: T,\r\n    strict: boolean = false\r\n): P & T {\r\n    if (strict) {\r\n        const filteredOptions = keys(options).reduce((acc, key) => {\r\n            if (options[key]) {\r\n                acc[key] = options[key];\r\n            }\r\n\r\n            return acc;\r\n        }, {} as T);\r\n\r\n        return Object.assign({}, defaultOptions, filteredOptions);\r\n    } else {\r\n        return Object.assign({}, defaultOptions, options);\r\n    }\r\n}\r\n\r\nexport function deepMerge<T extends IObject[]>(...objects: T): UnionToIntersection<T[any]> {\r\n    return objects.reduce((acc, obj) => {\r\n        if (isArray(obj)) {\r\n            return acc.concat(obj);\r\n        }\r\n\r\n        for (const key in obj) {\r\n            if (isArray(acc[key]) && isArray(obj[key])) {\r\n                acc[key] = acc[key].concat(obj[key]);\r\n            } else if (isObject(acc[key]) && isObject(obj[key])) {\r\n                acc[key] = deepMerge(acc[key], obj[key]);\r\n            } else {\r\n                acc[key] = obj[key];\r\n            }\r\n        }\r\n\r\n        return acc;\r\n    }, {});\r\n}\r\n\r\nexport function keys<T extends IObject>(obj: T): (keyof T)[] {\r\n    return Object.keys(obj) as (keyof T)[];\r\n}\r\n\r\nexport function values<T extends IObject>(obj: T): T[keyof T][] {\r\n    return keys(obj).map((key) => obj[key]);\r\n}\r\n\r\nexport function forEach<T>(obj: T, fn: (key: keyof T, value: T[keyof T], obj: T) => void): void {\r\n    if (isUndefined(obj)) {\r\n        return;\r\n    }\r\n\r\n    if (isArray(obj)) {\r\n        obj.forEach(function (value, index) {\r\n            fn.call(null, index, value, obj);\r\n        });\r\n    } else {\r\n        for (const key in obj) {\r\n            fn.call(null, key, obj[key], obj);\r\n        }\r\n    }\r\n}\r\n\r\nexport function extractMatchFromRegExp(\r\n    value: string | null,\r\n    regexp: RegExp,\r\n    group = 0,\r\n    defaultValue: any = null\r\n): string | null {\r\n    if (value) {\r\n        const matches = regexp.exec(value);\r\n\r\n        if (isArray(matches) && !isEmpty(matches)) {\r\n            return matches[group];\r\n        }\r\n    }\r\n\r\n    return defaultValue;\r\n}\r\n\r\nexport function startsWithReplacer(value: string, search: string, replace: string): string {\r\n    if (value.startsWith(search)) {\r\n        return value.replace(search, replace);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nexport function stringReplacer(value: string, search: string | RegExp, replace: string): string {\r\n    return value.replace(search, replace);\r\n}\r\n\r\nexport function ensureLeadingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.startsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${token}${value}`;\r\n}\r\n\r\nexport function ensureTrailingToken(token: string, value: string): string {\r\n    if (argumentIsNotProvided(value)) {\r\n        return \"\";\r\n    }\r\n\r\n    if (value.endsWith(token)) {\r\n        return value;\r\n    }\r\n\r\n    return `${value}${token}`;\r\n}\r\n\r\nexport function argumentIsNotProvided(value: unknown): boolean {\r\n    return value === undefined || value === null;\r\n}\r\n\r\nexport function combineStrings(delimiter = \"\", ...strings: string[]): string {\r\n    return strings.filter((string) => !isEmpty(string)).join(delimiter);\r\n}\r\n\r\nexport function replaceObjectProperty<T extends IObject, K extends keyof T>(\r\n    obj: T,\r\n    key: K,\r\n    value: T[K]\r\n): void {\r\n    Object.assign(obj, { [key]: value });\r\n}\r\n\r\nexport function safeStringify(value: any): string {\r\n    try {\r\n        return JSON.stringify(value);\r\n    } catch (error) {\r\n        return \"\";\r\n    }\r\n}\r\n\r\nexport function safeJSONParse(value: string, returnValueOnError = false): any {\r\n    try {\r\n        return JSON.parse(value);\r\n    } catch (error) {\r\n        if (returnValueOnError) {\r\n            return value;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n\r\nexport function createEmptyScheme<T>(keys: string[], value = null): T {\r\n    return keys.reduce((acc, key) => {\r\n        const keys = key.split(\".\");\r\n\r\n        if (keys.length === 1) {\r\n            acc[key] = value;\r\n        } else {\r\n            const [object, ...nestedKeys] = keys;\r\n\r\n            if (!acc[object]) {\r\n                acc[object] = {};\r\n            }\r\n\r\n            const nestedObject = createEmptyScheme(nestedKeys);\r\n            acc[object] = merge(acc[object], nestedObject);\r\n        }\r\n\r\n        return acc;\r\n    }, {} as T);\r\n}\r\n\r\nexport function mutate<T>(value: T, mutator: (value: T) => void): T {\r\n    mutator(value);\r\n    return value;\r\n}\r\n","import type { InternalConfiguration, URLComponent, UrbexResponse } from \"../exportable-types\";\r\nimport type { ParsedURLComponent, PipelineExecutorsManager } from \"../types\";\r\n\r\nimport { createEmptyScheme } from \"../utils\";\r\n\r\nexport const REQUEST_BODY_METHODS = [\"POST\", \"PUT\", \"PATCH\"];\r\n\r\nexport const URL_COMPONENT_KEYS: (keyof URLComponent)[] = [\r\n    \"href\",\r\n    \"origin\",\r\n    \"protocol\",\r\n    \"username\",\r\n    \"password\",\r\n    \"hostname\",\r\n    \"port\",\r\n    \"pathname\",\r\n    \"search\",\r\n    \"searchParams\",\r\n    \"hash\"\r\n];\r\n\r\nexport const DEFAULT_URL_COMPONENT = createEmptyScheme<ParsedURLComponent>(URL_COMPONENT_KEYS, \"\");\r\n\r\nexport const DEFAULT_PIPELINE_EXECUTORS: PipelineExecutorsManager = {\r\n    request: [],\r\n    response: []\r\n};\r\n\r\nexport const DEFAULT_CLIENT_OPTIONS: InternalConfiguration = {\r\n    url: null,\r\n    timeout: 0,\r\n    method: \"GET\",\r\n    headers: null,\r\n    data: null,\r\n    cache: {},\r\n    pipelines: DEFAULT_PIPELINE_EXECUTORS,\r\n    maxContentLength: Infinity,\r\n    responseType: \"json\",\r\n    responseEncoding: \"utf8\",\r\n    resolveStatus: (config, status) => {\r\n        return status >= 200 && status < 300;\r\n    }\r\n};\r\n\r\nexport const DEFAULT_URBEX_RESPONSE = createEmptyScheme<UrbexResponse>([\r\n    \"status\",\r\n    \"statusText\",\r\n    \"headers\",\r\n    \"data\",\r\n    \"config\",\r\n    \"request\",\r\n    \"response\",\r\n    \"duration\",\r\n    \"timestamp\",\r\n    \"cache.key\",\r\n    \"cache.hit\",\r\n    \"cache.pulled\",\r\n    \"cache.stored\"\r\n]);\r\n\r\nexport const METHODS = [\"PUT\", \"POST\", \"PATCH\", \"OPTIONS\", \"HEAD\", \"GET\", \"DELETE\"];\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\n\r\nimport {\r\n    merge,\r\n    isString,\r\n    isNumber,\r\n    isEmpty,\r\n    isArray,\r\n    isObject,\r\n    createEmptyScheme,\r\n    lowercase,\r\n    combineStrings,\r\n    ensureTrailingToken,\r\n    ensureLeadingToken,\r\n    forEach\r\n} from \"../../utils\";\r\nimport { URL_COMPONENT_KEYS } from \"../constants\";\r\n\r\ninterface ParamsConversionOutput {\r\n    /**\r\n     * Stringified output of the search parameters.\r\n     */\r\n    search: string;\r\n    /**\r\n     * As a URLSearchParams object.\r\n     */\r\n    searchParams: URLSearchParams;\r\n}\r\n\r\nconst DEFAULT_PROTOCOL = \"http\";\r\n\r\nconst PARSE_URL =\r\n    /^(?:([^:\\/?#]+):)?(?:[\\/\\/]+((?:([^@\\/\\n]+)@)?((?:[0-9]{1,3}\\.){3}[0-9]{1,3}|\\[[0-9a-f:]+\\]|[^#:\\/?\\n]+)(?::(\\d*))?))?(?:[\\/]*([^?#]*))(?:[\\?]*([^#]*))?(?:[\\#]*(.*))?/i;\r\n\r\nconst IPV4_REGEX = /^(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})$/;\r\nconst IPV6_REGEX = /^(\\[[0-9a-f:]+\\])$/i;\r\nconst AUTH_REGEX = /^([^:]+)(?:\\:([^:].+))?/;\r\nconst PORT_LOWER_LIMIT = 0;\r\nconst PORT_UPPER_LIMIT = 65535;\r\n\r\nfunction removeEncodedWhitespace(input: string): string {\r\n    return input.replace(/%20/g, \"\");\r\n}\r\n\r\nfunction normalizeIPv4(input: string): string {\r\n    const matches = IPV4_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        const numbers = matches.slice(1).map((num) => parseInt(num, 10));\r\n\r\n        if (numbers.every((num) => num <= 255)) {\r\n            return numbers.join(\".\");\r\n        }\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv4 address.\");\r\n}\r\n\r\nfunction normalizeIPv6(input: string): string {\r\n    const matches = IPV6_REGEX.exec(input);\r\n\r\n    if (matches) {\r\n        return matches[1];\r\n    }\r\n\r\n    throw new Error(\"Invalid IPv6 address.\");\r\n}\r\n\r\nfunction formatPort(port: Port): string {\r\n    if (!port) {\r\n        return \"\";\r\n    }\r\n\r\n    if (isNumber(port) || !port.startsWith(\":\")) {\r\n        return `:${port}`;\r\n    } else {\r\n        return port;\r\n    }\r\n}\r\n\r\nexport function mergeAuth(username: string, password: string): string {\r\n    if (!username && password) {\r\n        throw new Error(\"Cannot set password without username.\");\r\n    }\r\n\r\n    if (!username) {\r\n        return \"\";\r\n    }\r\n\r\n    if (!password) {\r\n        return username;\r\n    }\r\n\r\n    return combineStrings(\":\", username, password);\r\n}\r\n\r\nexport function buildProtocol(protocol: string, hasHostname: boolean): string {\r\n    if (hasHostname || protocol === \"http\" || protocol === \"https\") {\r\n        return ensureTrailingToken(\"://\", protocol);\r\n    }\r\n\r\n    return ensureTrailingToken(\":\", protocol);\r\n}\r\n\r\nexport function extractScheme(input: string): string {\r\n    return input.replace(/:\\/\\/$/, \"\").replace(/:$/, \"\");\r\n}\r\n\r\nexport function convertSearchParamsToString(search: CustomSearchParams): ParamsConversionOutput {\r\n    if (!search || (!isString(search) && !isObject(search) && !isArray(search))) {\r\n        return {\r\n            search: \"\",\r\n            searchParams: null\r\n        };\r\n    }\r\n\r\n    if (isString(search)) {\r\n        return {\r\n            search: ensureLeadingToken(\"?\", removeEncodedWhitespace(search)),\r\n            searchParams: new URLSearchParams(search)\r\n        };\r\n    }\r\n\r\n    const searchParams = new URLSearchParams();\r\n\r\n    forEach(search, (key, value) => {\r\n        if (value) {\r\n            if (isArray(value)) {\r\n                const entry = value;\r\n                searchParams.append(entry[0] as string, entry[1] as string);\r\n            } else if (isObject(search)) {\r\n                searchParams.append(key, value);\r\n            }\r\n        }\r\n    });\r\n\r\n    return {\r\n        search: ensureLeadingToken(\"?\", searchParams.toString()),\r\n        searchParams: searchParams\r\n    };\r\n}\r\n\r\nexport class BaseURLParser {\r\n    protected $component: EnforceComponent;\r\n\r\n    constructor(input: string | SerializeComponent) {\r\n        if (input && !isString(input) && !isObject(input)) {\r\n            throw new TypeError(\"Invalid input. Must be a string or an object.\");\r\n        }\r\n\r\n        this.$component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        this.$component.searchParams = new URLSearchParams();\r\n\r\n        if (isString(input) && input) {\r\n            this.$component = this.parse(input);\r\n            return;\r\n        }\r\n\r\n        if (isObject(input) && !isEmpty(input)) {\r\n            if (input.href) {\r\n                this.$component = this.parse(input.href);\r\n            } else {\r\n                this.serialize(input);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    protected sync(\r\n        value: string,\r\n        replace: string,\r\n        syncType: \"all\" | \"href\" | \"origin\" = \"all\"\r\n    ): void {\r\n        const href = this.$component.href;\r\n        const origin = this.$component.origin;\r\n\r\n        if (value) {\r\n            if (syncType === \"all\" || syncType === \"href\") {\r\n                this.$component.href = href.replace(value, replace);\r\n            }\r\n\r\n            if (syncType === \"all\" || syncType === \"origin\") {\r\n                this.$component.origin = origin.replace(value, replace);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected syncAuth(origin: string, username: string, password: string): void {\r\n        if (!username) {\r\n            throw new Error(\"Cannot set password without username.\");\r\n        }\r\n\r\n        let [protocol, host] = origin.split(\"://\");\r\n\r\n        protocol = buildProtocol(protocol, !!host);\r\n\r\n        const authString = combineStrings(\"\", mergeAuth(username, password), \"@\");\r\n\r\n        this.$component.href = combineStrings(\"\", protocol, authString, host);\r\n    }\r\n\r\n    protected match(input: string): string[] {\r\n        return PARSE_URL.exec(input);\r\n    }\r\n\r\n    protected parseProtocol(input: string): string {\r\n        if (!input) {\r\n            const protocol = this.$component.protocol;\r\n            this.$component.protocol = protocol || DEFAULT_PROTOCOL;\r\n            return;\r\n        }\r\n\r\n        input = extractScheme(input);\r\n\r\n        const protocol = lowercase(removeEncodedWhitespace(input));\r\n        this.$component.protocol = protocol;\r\n    }\r\n\r\n    protected parseAuth(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const auth = AUTH_REGEX.exec(input);\r\n\r\n        if (auth && auth.length) {\r\n            const username = auth[1];\r\n            const password = auth[2];\r\n\r\n            if (!username) {\r\n                throw new Error(\"Expected username in auth.\");\r\n            }\r\n\r\n            this.$component.username = username;\r\n            this.$component.password = password || \"\";\r\n        } else {\r\n            throw new Error(\"Invalid auth format. Expected <username>:<password>\");\r\n        }\r\n    }\r\n\r\n    protected parseHostname(input: string): void {\r\n        if (!input) {\r\n            return;\r\n        }\r\n\r\n        const isIPv4 = IPV4_REGEX.test(input);\r\n\r\n        if (isIPv4) {\r\n            input = normalizeIPv4(input);\r\n        } else {\r\n            const isIPv6 = IPV6_REGEX.test(input);\r\n            if (isIPv6) {\r\n                input = normalizeIPv6(input);\r\n            } else {\r\n                input = lowercase(input);\r\n            }\r\n        }\r\n\r\n        this.$component.hostname = removeEncodedWhitespace(input);\r\n    }\r\n\r\n    protected parsePort(port: Port): void {\r\n        if (!port) {\r\n            this.$component.port = \"\";\r\n            return;\r\n        }\r\n\r\n        const parsePort = isNumber(port) ? port : parseInt(port, 10);\r\n\r\n        if (isNaN(parsePort) || parsePort < PORT_LOWER_LIMIT || parsePort > PORT_UPPER_LIMIT) {\r\n            throw new Error(\"Port must be between 0 and 65535.\");\r\n        }\r\n\r\n        this.$component.port = parsePort;\r\n    }\r\n\r\n    protected parseOrigin(origin: string): void {\r\n        const protocol = buildProtocol(this.$component.protocol, !!this.$component.hostname);\r\n\r\n        if (!origin || !this.$component.hostname) {\r\n            this.$component.origin = \"null\";\r\n        } else {\r\n            this.$component.origin = ensureLeadingToken(protocol, origin);\r\n        }\r\n\r\n        const authString = mergeAuth(this.$component.username, this.$component.password);\r\n\r\n        if (authString && this.$component.origin.includes(authString)) {\r\n            const replaceAuth = combineStrings(\"\", authString, \"@\");\r\n            this.$component.origin = this.$component.origin.replace(replaceAuth, \"\");\r\n        }\r\n    }\r\n\r\n    protected parsePathname(pathname: string): void {\r\n        if (!pathname) {\r\n            return;\r\n        }\r\n\r\n        if (this.$component.hostname) {\r\n            this.$component.pathname = ensureLeadingToken(\"/\", pathname);\r\n        } else {\r\n            this.$component.pathname = pathname;\r\n        }\r\n    }\r\n\r\n    protected parseParams(params: CustomSearchParams): void {\r\n        if (!params) {\r\n            return;\r\n        }\r\n\r\n        const search = convertSearchParamsToString(params);\r\n\r\n        if (search) {\r\n            this.$component.search = ensureLeadingToken(\"?\", search.search);\r\n            this.$component.searchParams = new URLSearchParams(search.searchParams);\r\n        }\r\n    }\r\n\r\n    protected parseHash(hash: string): void {\r\n        if (!hash) {\r\n            return;\r\n        }\r\n\r\n        this.$component.hash = ensureLeadingToken(\"#\", hash);\r\n    }\r\n\r\n    /**\r\n     * Parses a URL string and returns a URL object.\r\n     */\r\n    public parse(input: string, overwrite: boolean = true): EnforceComponent {\r\n        if (!isString(input) || isEmpty(input)) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const component = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        component.searchParams = new URLSearchParams();\r\n\r\n        if (overwrite) {\r\n            this.$component = component;\r\n        } else {\r\n            this.$component = merge(component, this.$component);\r\n        }\r\n\r\n        input = input.trim();\r\n        input = input.replace(/\\s/g, \"%20\");\r\n        input = input.replace(/\\\\/g, \"/\");\r\n\r\n        const matches = this.match(input);\r\n\r\n        if (matches === null || matches.length === 0) {\r\n            throw new Error(\"Invalid URL.\");\r\n        }\r\n\r\n        const [href, protocol, origin, auth, hostname, port, pathname, query, hash] = matches;\r\n\r\n        this.parseProtocol(protocol);\r\n        this.parseAuth(auth);\r\n        this.parseHostname(hostname);\r\n        this.parsePort(port);\r\n        this.parsePathname(pathname);\r\n        this.parseParams(query);\r\n        this.parseHash(hash);\r\n        this.parseOrigin(origin);\r\n\r\n        this.$component.href = href;\r\n\r\n        return this.$component;\r\n    }\r\n\r\n    /**\r\n     * Serializes a URL object into a URL string.\r\n     */\r\n    public serialize(_component: SerializeComponent, overwrite: boolean = true): string {\r\n        const baseComponent = createEmptyScheme<EnforceComponent>(URL_COMPONENT_KEYS, \"\");\r\n        const component = merge(baseComponent, _component);\r\n\r\n        const tokens: string[] = [];\r\n\r\n        const authString = mergeAuth(component.username, component.password);\r\n\r\n        if (component.origin) {\r\n            const [_, protocol, origin, auth, host, port] = this.match(component.origin);\r\n\r\n            tokens.push(buildProtocol(protocol, !!host));\r\n\r\n            if (authString && !component.origin.includes(authString)) {\r\n                // this is a safe check to ensure the user didn't provide a username/password\r\n                // in the origin string. If they did, we'll remove it and use the one provided\r\n                // in the username/password properties.\r\n\r\n                const newOrigin = origin.replace(`${auth}@`, \"\");\r\n\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n                tokens.push(newOrigin);\r\n            } else {\r\n                if (auth) {\r\n                    tokens.push(auth);\r\n                    tokens.push(\"@\");\r\n                }\r\n\r\n                tokens.push(host);\r\n\r\n                if (port) {\r\n                    tokens.push(formatPort(port));\r\n                }\r\n            }\r\n        } else {\r\n            if (!component.protocol) {\r\n                throw new Error(\"Expected a protocol when serializing a URL.\");\r\n            }\r\n\r\n            if (component.protocol === \"http\" || component.protocol === \"https\") {\r\n                if (!component.hostname) {\r\n                    throw new Error(\r\n                        \"Expected a hostname when serializing a URL with an HTTP protocol.\"\r\n                    );\r\n                }\r\n            }\r\n\r\n            tokens.push(buildProtocol(component.protocol, !!component.hostname));\r\n\r\n            if (authString) {\r\n                tokens.push(authString);\r\n                tokens.push(\"@\");\r\n            }\r\n\r\n            if (component.hostname) {\r\n                tokens.push(component.hostname);\r\n            }\r\n\r\n            tokens.push(formatPort(component.port));\r\n        }\r\n\r\n        tokens.push(ensureLeadingToken(\"/\", component.pathname));\r\n\r\n        const searchParams = component.search || component.searchParams || \"\";\r\n\r\n        if (searchParams) {\r\n            if (searchParams instanceof URLSearchParams) {\r\n                const search = searchParams.toString();\r\n\r\n                if (search) {\r\n                    tokens.push(ensureLeadingToken(\"?\", search));\r\n                }\r\n            } else {\r\n                const { search } = convertSearchParamsToString(searchParams.toString());\r\n                tokens.push(ensureLeadingToken(\"?\", search));\r\n            }\r\n        }\r\n\r\n        if (component.hash) {\r\n            tokens.push(ensureLeadingToken(\"#\", component.hash));\r\n        }\r\n\r\n        const url = tokens.filter((token) => token && token !== \"/\").join(\"\");\r\n\r\n        try {\r\n            const parsed = this.parse(url, overwrite);\r\n            return parsed.href;\r\n        } catch (error) {\r\n            throw new Error(\"Attempted to serialize an invalid URL.\");\r\n        }\r\n    }\r\n}\r\n","import type { CustomSearchParams, SerializeComponent, EnforceComponent, Port } from \"../../types\";\r\nimport { combineStrings, ensureLeadingToken } from \"../../utils\";\r\n\r\nimport {\r\n    BaseURLParser,\r\n    mergeAuth,\r\n    extractScheme,\r\n    buildProtocol,\r\n    convertSearchParamsToString\r\n} from \"./base-url-parser\";\r\nimport { merge } from \"../../utils\";\r\n\r\n// build this as a seperate package\r\n\r\n/**\r\n * The internal URL parser that is responsible for parsing and serializing\r\n * URLs and their components.\r\n */\r\nexport class URLParser extends BaseURLParser {\r\n    constructor(input?: string | SerializeComponent) {\r\n        super(input);\r\n    }\r\n\r\n    /**\r\n     * Parse the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static parse(input: string): URLParser {\r\n        return new this(input);\r\n    }\r\n\r\n    /**\r\n     * Serialize the input and return a new instance of the `URLParser` class.\r\n     */\r\n    static serialize(component: SerializeComponent): string {\r\n        return new this().serialize(component);\r\n    }\r\n\r\n    /**\r\n     * Set a component object without enforcing the component to serialize\r\n     * or parse. Merges the component with the existing component.\r\n     *\r\n     * This does not validate the component.\r\n     */\r\n    public set(component: SerializeComponent): this {\r\n        this.$component = merge(this.$component, component);\r\n\r\n        if (component.searchParams instanceof URLSearchParams) {\r\n            this.$component.search = component.searchParams.toString();\r\n            this.$component.searchParams = component.searchParams;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public get href(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public set href(value: string) {\r\n        this.parse(value);\r\n    }\r\n\r\n    public get origin(): string {\r\n        return this.$component.origin;\r\n    }\r\n\r\n    public set origin(value: string) {\r\n        const [href, protocol, origin, auth, hostname, port] = this.match(value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        const component = merge<EnforceComponent, SerializeComponent>(this.$component, {\r\n            href: \"\",\r\n            origin: combineStrings(\"\", buildProtocol(protocol, !!hostname), origin)\r\n        });\r\n\r\n        this.serialize(component);\r\n    }\r\n\r\n    public get protocol(): string {\r\n        return this.$component.protocol;\r\n    }\r\n\r\n    public set protocol(value: string) {\r\n        if (value === this.protocol) {\r\n            return;\r\n        }\r\n\r\n        const existing = buildProtocol(this.protocol, !!this.hostname);\r\n        const incoming = buildProtocol(extractScheme(value), !value.includes(\"data\"));\r\n\r\n        this.parseProtocol(value);\r\n\r\n        this.sync(existing, incoming);\r\n    }\r\n\r\n    public get username(): string {\r\n        return this.$component.username;\r\n    }\r\n\r\n    public set username(value: string) {\r\n        const existing = this.username;\r\n\r\n        if (value === this.username) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(value, this.password);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get password(): string {\r\n        return this.$component.password;\r\n    }\r\n\r\n    public set password(value: string) {\r\n        const existing = this.password;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        const auth = mergeAuth(this.username, value);\r\n\r\n        this.parseAuth(auth);\r\n\r\n        if (existing) {\r\n            this.sync(existing, value);\r\n        } else if (this.origin) {\r\n            this.syncAuth(this.origin, this.username, this.password);\r\n        }\r\n    }\r\n\r\n    public get hostname(): string {\r\n        return this.$component.hostname;\r\n    }\r\n\r\n    public set hostname(value: string) {\r\n        const existing = this.hostname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHostname(value);\r\n        this.sync(existing, this.hostname);\r\n    }\r\n\r\n    public get port(): Port {\r\n        return this.$component.port;\r\n    }\r\n\r\n    public set port(value: Port) {\r\n        const existing = this.port.toString();\r\n\r\n        if (value.toString() === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePort(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.port.toString());\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const originWithPort = combineStrings(\":\", origin, this.port.toString());\r\n\r\n            this.sync(origin, originWithPort);\r\n        }\r\n    }\r\n\r\n    public get pathname(): string {\r\n        return this.$component.pathname;\r\n    }\r\n\r\n    public set pathname(value: string) {\r\n        const existing = this.pathname;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parsePathname(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.pathname);\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const pathname = ensureLeadingToken(\"/\", this.pathname);\r\n            const originwithPathname = combineStrings(\"\", origin, pathname);\r\n\r\n            this.sync(origin, originwithPathname, \"href\");\r\n        }\r\n    }\r\n\r\n    public get search(): string {\r\n        return convertSearchParamsToString(this.$component.search).search;\r\n    }\r\n\r\n    public get searchParams(): URLSearchParams {\r\n        return this.$component.searchParams;\r\n    }\r\n\r\n    public get hash(): string {\r\n        return this.$component.hash;\r\n    }\r\n\r\n    public set hash(value: string) {\r\n        const existing = this.hash;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        this.parseHash(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.hash, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const hash = ensureLeadingToken(\"#\", this.hash);\r\n            const originwithHash = combineStrings(\"\", origin, hash);\r\n\r\n            this.sync(origin, originwithHash, \"href\");\r\n        }\r\n    }\r\n\r\n    public setSearchParams(value: CustomSearchParams | URLSearchParams, merge: boolean = false) {\r\n        const existing = this.search;\r\n\r\n        if (value === existing) {\r\n            return;\r\n        }\r\n\r\n        if (value instanceof URLSearchParams) {\r\n            value = value.toString();\r\n        }\r\n\r\n        this.parseParams(value);\r\n\r\n        if (existing) {\r\n            this.sync(existing, this.search, \"href\");\r\n        } else if (this.origin) {\r\n            const origin = this.origin;\r\n            const search = ensureLeadingToken(\"?\", this.search);\r\n            const originwithSearch = combineStrings(\"\", origin, search);\r\n\r\n            this.sync(origin, originwithSearch, \"href\");\r\n        }\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.$component.href;\r\n    }\r\n\r\n    public toJSON(): EnforceComponent {\r\n        return this.$component;\r\n    }\r\n}\r\n","import { URLParser } from \"./core/parsers/url-parser\";\r\n\r\nexport type UrbexContext = \"browser\" | \"node\";\r\n\r\nexport class Environment {\r\n    private _context: UrbexContext;\r\n\r\n    constructor() {\r\n        this._context = this.detectContext();\r\n    }\r\n\r\n    private detectContext(): UrbexContext {\r\n        if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\r\n            return \"browser\";\r\n        }\r\n\r\n        if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n            return \"node\";\r\n        }\r\n\r\n        throw new Error(\"Unable to detect environment context.\");\r\n    }\r\n\r\n    private nodeStrictCheck(): void {\r\n        if (this.isBrowser) {\r\n            throw new Error(\"This method is not available in the browser environment.\");\r\n        }\r\n    }\r\n\r\n    get process(): NodeJS.Process {\r\n        if (this.isNode) {\r\n            return process;\r\n        }\r\n\r\n        return {} as NodeJS.Process;\r\n    }\r\n\r\n    get context(): UrbexContext {\r\n        return this._context;\r\n    }\r\n\r\n    get isBrowser(): boolean {\r\n        return this.context === \"browser\";\r\n    }\r\n\r\n    get isNode(): boolean {\r\n        return this.context === \"node\";\r\n    }\r\n\r\n    get isDevelopment(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"development\";\r\n    }\r\n\r\n    get isProduction(): boolean {\r\n        this.nodeStrictCheck();\r\n\r\n        return process.env.NODE_ENV === \"production\";\r\n    }\r\n\r\n    public getEnvironmentComponent(): URLParser {\r\n        if (this.isBrowser) {\r\n            return URLParser.parse(window.location.href);\r\n        } else {\r\n            const port = process.env.PORT || \"3000\";\r\n            const parsed = URLParser.parse(`http://localhost:${port}`);\r\n\r\n            return parsed;\r\n        }\r\n    }\r\n}\r\n\r\nexport const environment = new Environment();\r\n","/**\n    * https://github.com/itsmichaelbtw/cache-clock#readme\n    * (c) 2022 Michael Cizek\n    * @license MIT\n    */\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\nfunction isPureObject(value) {\n  return _typeof(value) === \"object\" && value !== null && !Array.isArray(value);\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !isNaN(value);\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNegative(value) {\n  return value < 0;\n}\nfunction absolute(value) {\n  return Math.abs(value);\n}\nfunction shallowMerge(target, source) {\n  return Object.assign({}, target, source);\n}\nfunction stringify(value) {\n  if (isUndefined(value)) {\n    return \"\";\n  }\n  if (isString(value)) {\n    return value;\n  }\n  return JSON.stringify(value);\n}\n\nfunction getCurrentEnvironment() {\n  if (typeof window !== \"undefined\" && typeof window.document !== \"undefined\") {\n    return \"browser\";\n  }\n  if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n    return \"node\";\n  }\n  return \"unknown\";\n}\nvar environment = getCurrentEnvironment();\n\nvar colors = {\n  red: \"\\x1b[31m\",\n  yellow: \"\\x1b[33m\",\n  green: \"\\x1b[32m\",\n  lightblue: \"\\x1b[36m\"\n};\nvar globals = {\n  reset: \"\\x1b[0m\",\n  bright: \"\\x1b[1m\"\n};\nfunction debug(message, color) {\n  if (debug.DEBUG) {\n    var prefix = \"[CACHE-CLOCK] \";\n    var colorizedMessage = \"\".concat(colors[color]).concat(prefix).concat(message).concat(globals.reset);\n    console.log(colorizedMessage);\n  }\n}\ndebug.DEBUG = false;\n\nfunction hash(input) {\n  if (typeof input !== \"string\") {\n    input = JSON.stringify(input);\n  }\n  var numberHash = input.split(\"\").reduce(function (a, b) {\n    a = (a << 5) - a + a * 24 + b.charCodeAt(0);\n    a |= 0;\n    return a;\n  }, 0);\n  return numberHash.toString(32);\n}\n\nvar _Symbol$iterator;\nvar timeProvider = Date;\nvar DEFAULT_CLOCK_OPTIONS = {\n  maxItems: 1000,\n  ttl: Infinity,\n  interval: 15 * 1000,\n  debug: false,\n  autoStart: true,\n  overwrite: false,\n  resetTimeoutOnAccess: false\n};\nfunction invokeTimeout(callback, delay) {\n  var timeout = environment === \"node\" ? global.setTimeout : window.setTimeout;\n  return timeout.call(null, callback, delay);\n}\nfunction parseCacheOptions() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var defaultOptions = arguments.length > 1 ? arguments[1] : undefined;\n  if (!isPureObject(options)) {\n    debug(\"Invalid options passed to cache clock, using defaults.\", \"yellow\");\n    return defaultOptions;\n  }\n  var opts = shallowMerge(defaultOptions, options);\n  if (isNumber(opts.maxItems) && isNegative(opts.maxItems)) {\n    opts.maxItems = absolute(opts.maxItems);\n  } else if (!isNumber(opts.maxItems)) {\n    opts.maxItems = defaultOptions.maxItems;\n  }\n  if (isNumber(opts.ttl) && isNegative(opts.ttl)) {\n    opts.ttl = absolute(opts.ttl);\n  } else if (!isNumber(opts.maxItems)) {\n    opts.ttl = defaultOptions.ttl;\n  }\n  if (isNumber(opts.interval) && isNegative(opts.interval)) {\n    opts.interval = absolute(opts.interval);\n  } else if (!isNumber(opts.interval)) {\n    opts.interval = defaultOptions.interval;\n  }\n  if (opts.onExpire && !isFunction(opts.onExpire)) {\n    opts.onExpire = undefined;\n  }\n  if (opts.maxItems === 0) {\n    opts.maxItems = 1;\n  }\n  return opts;\n}\nfunction createEntityKey(key, isHashed) {\n  if (isHashed) {\n    return key;\n  }\n  return hash(stringify(key));\n}\nvar DEFAULT_STATISTCS = {\n  hits: 0,\n  sets: 0,\n  misses: 0,\n  evictions: 0,\n  expired: 0,\n  deletes: 0,\n  overwrites: 0,\n  clears: 0,\n  lifecycles: 0\n};\n_Symbol$iterator = Symbol.iterator;\nvar CacheClock = /*#__PURE__*/function () {\n  /**\n   * Create a new instance of the cache clock. You can\n   * pass a configuration object to set the default\n   * options for all cacheable items.\n   *\n   * ```js\n   * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });\n   * ```\n   */\n  function CacheClock(options) {\n    _classCallCheck(this, CacheClock);\n    _defineProperty(this, \"$birth\", void 0);\n    _defineProperty(this, \"$cache\", void 0);\n    _defineProperty(this, \"$clock\", void 0);\n    _defineProperty(this, \"$options\", void 0);\n    _defineProperty(this, \"$statistics\", void 0);\n    this.$birth = timeProvider.now();\n    this.$cache = new Map();\n    this.configure(options);\n    this.$statistics = Object.assign({}, DEFAULT_STATISTCS);\n    if (this.options.autoStart) {\n      this.start();\n    }\n  }\n  _createClass(CacheClock, [{\n    key: \"prune\",\n    value: function prune() {\n      this.stop();\n      var now = timeProvider.now();\n      var _iterator = _createForOfIteratorHelper(this),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var value = _step.value;\n          if (value.e <= now) {\n            var _entry = this.del(value.k, true);\n            if (this.options.onExpire && _entry) {\n              this.options.onExpire(_entry);\n            }\n            this.$statistics.expired++;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this.start();\n    }\n\n    /**\n     * Create a new instance of the cache clock. You can\n     * pass a configuration object to set the default\n     * options for all cacheable items.\n     *\n     * ```js\n     * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });\n     * ```\n     */\n  }, {\n    key: \"age\",\n    get:\n    /**\n     * The age of the cache clock in `ms`.\n     */\n    function get() {\n      return timeProvider.now() - this.$birth;\n    }\n\n    /**\n     * The number of items in the cache.\n     */\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.$cache.size;\n    }\n\n    /**\n     * Global configuration that applies to all cacheable items.\n     */\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this.$options;\n    }\n  }, {\n    key: \"stats\",\n    get: function get() {\n      return this.$statistics;\n    }\n\n    /**\n     * Whether the clock is currently running.\n     */\n  }, {\n    key: \"isRunning\",\n    get: function get() {\n      return !!this.$clock;\n    }\n\n    /**\n     * Configure the cache clock. Use this method to change the global configuration\n     * that applies to all cacheable items.\n     *\n     * Items that have been cached prior to updating the configuration will not be\n     * affected.\n     *\n     * ```js\n     * const clock = new CacheClock();\n     * clock.configure({ ttl: 5 * 60 * 1000 });\n     * ```\n     */\n  }, {\n    key: \"configure\",\n    value: function configure() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.$options = parseCacheOptions(options, this.options || DEFAULT_CLOCK_OPTIONS);\n      debug.DEBUG = this.options.debug;\n      if (this.options.interval < DEFAULT_CLOCK_OPTIONS.interval) {\n        debug(\"A cache clock interval less than 15 seconds is not recommended.\", \"yellow\");\n      }\n    }\n\n    /**\n     * Create a cache key based on the input.\n     */\n  }, {\n    key: \"getCacheKey\",\n    value: function getCacheKey(input) {\n      return createEntityKey(input, false);\n    }\n\n    /**\n     * Start the cache clock. This is automatically called when the cache clock is created.\n     * You should only need to call this method if you have stopped the cache clock manually.\n     *\n     * This will spawn a new clock with the full timeout interval. This does not resume the\n     * clock from where it left off.\n     */\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.options.interval === Infinity || this.options.interval === 0) {\n        debug(\"Disabling the clock due to an unsupported interval.\", \"yellow\");\n        return;\n      }\n      if (this.$clock) {\n        debug(\"Cache clock is already running. Unable to start.\", \"red\");\n        return;\n      }\n      this.$clock = invokeTimeout(this.prune.bind(this), this.options.interval);\n    }\n\n    /**\n     * Manually stop the cache clock. This will disable the automatic expiration of items. This does\n     * not prevent items from being checked for expiration.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this.$clock) {\n        debug(\"Cache clock is not running. Unable to stop.\", \"red\");\n        return;\n      }\n      clearTimeout(this.$clock);\n      this.$clock = null;\n      this.$statistics.lifecycles++;\n    }\n\n    /**\n     * Add an item to the cache. Optionally, you can specify a time to live for the item.\n     *\n     * If the cache is full, the oldest item will be removed.\n     */\n  }, {\n    key: \"set\",\n    value: function set(key, value, options) {\n      var hashedKey = createEntityKey(key, false);\n      var _parseCacheOptions = parseCacheOptions(options, this.options),\n        ttl = _parseCacheOptions.ttl,\n        overwrite = _parseCacheOptions.overwrite;\n      var clockItem = {\n        k: hashedKey,\n        v: value,\n        t: ttl,\n        e: timeProvider.now() + ttl\n      };\n      var existingEntry = this.get(hashedKey, true);\n      if (existingEntry) {\n        if (overwrite) {\n          debug(\"Overwriting existing cache entry for key \\\"\".concat(hashedKey, \"\\\".\"), \"yellow\");\n          this.del(hashedKey, true);\n          this.$statistics.overwrites++;\n        } else {\n          debug(\"Unable to set cache item \\\"\".concat(hashedKey, \"\\\". The item already exists.\"), \"red\");\n          return existingEntry;\n        }\n      }\n      if (this.size >= this.options.maxItems) {\n        debug(\"The cache is full, removing oldest item.\", \"yellow\");\n        this.del(this.$cache.keys().next().value, true);\n        this.$statistics.evictions++;\n      }\n      this.$cache.set(hashedKey, clockItem);\n      this.$statistics.sets++;\n      return clockItem;\n    }\n\n    /**\n     * Retrieve an item from the cache. This returns the internal\n     * `CacheEntry` used to store the value.\n     */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var item = this.$cache.get(hashedKey);\n      this.$statistics.hits++;\n      if (isUndefined(item)) {\n        this.$statistics.misses++;\n        return undefined;\n      }\n      var now = timeProvider.now();\n      if (item.e < now) {\n        debug(\"Cache item \".concat(key, \" has expired.\"), \"red\");\n        this.del(hashedKey, true);\n        this.$statistics.expired++;\n        return undefined;\n      }\n      if (this.options.resetTimeoutOnAccess) {\n        item.e = now + item.t;\n      }\n      return item;\n    }\n\n    /**\n     * Deletes an item from the cache. Returns the deleted item\n     * if it exists.\n     */\n  }, {\n    key: \"del\",\n    value: function del(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var item = this.$cache.get(hashedKey);\n      if (isUndefined(item)) {\n        return undefined;\n      }\n      debug(\"Deleting cache item \".concat(key, \".\"), \"green\");\n      this.$cache[\"delete\"](hashedKey);\n      this.$statistics.deletes++;\n      return item;\n    }\n\n    /**\n     * Returns a boolean indicating whether the cache contains an item.\n     */\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hashedKey = createEntityKey(key, isHashed);\n      var entry = this.get(hashedKey, true);\n      return !isUndefined(entry);\n    }\n\n    /**\n     * Wipe the cache clean.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.$cache.clear();\n      this.$statistics.clears++;\n    }\n\n    /**\n     * Reset the cache statistics.\n     */\n  }, {\n    key: \"resetStats\",\n    value: function resetStats() {\n      this.$statistics = Object.assign({}, DEFAULT_STATISTCS);\n    }\n\n    /**\n     * Returns a JSON representation of the cache.\n     */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Array.from(this.$cache.values());\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this.$cache.values();\n    }\n  }], [{\n    key: \"create\",\n    value: function create() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new CacheClock(options);\n    }\n  }]);\n  return CacheClock;\n}();\n\nexport { CacheClock };\n//# sourceMappingURL=index.esm.js.map\n","import type { InternalConfiguration, UrbexErrorType, UrbexResponse } from \"../exportable-types\";\r\n\r\ninterface ErrorInstanceBinding {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nfunction replaceCallStackWithName(stack: string, name: string): string {\r\n    return stack.replace(/^Error/, name);\r\n}\r\n\r\n/**\r\n * Base error class for Urbex that extends the native Error class.\r\n */\r\nexport class UrbexError extends Error implements UrbexErrorType {\r\n    status: number;\r\n    request: any;\r\n    config: InternalConfiguration<any>;\r\n    response: UrbexResponse<any>;\r\n    message: string = \"An error occurred while executing a request.\";\r\n\r\n    static create<T extends typeof UrbexError>(\r\n        this: T,\r\n        config?: InternalConfiguration\r\n    ): InstanceType<T> {\r\n        const error = new this();\r\n        error.config = config;\r\n        error.name = this.name;\r\n\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createErrorInstance<T extends typeof UrbexError>(\r\n        this: ErrorInstanceBinding,\r\n        instance: T\r\n    ): InstanceType<T> {\r\n        const error = instance.create.call(instance, this.config);\r\n        error.request = this.request;\r\n        return error as InstanceType<T>;\r\n    }\r\n\r\n    static createFromError<T extends typeof UrbexError>(this: T, error: Error): InstanceType<T> {\r\n        if (!(error instanceof Error)) {\r\n            error = new Error(error);\r\n        }\r\n\r\n        const instance = new this(error.message);\r\n\r\n        if (error.stack) {\r\n            instance.stack = replaceCallStackWithName(error.stack, this.name);\r\n        }\r\n\r\n        instance.name = this.name;\r\n\r\n        if (UrbexError.isInstance(error)) {\r\n            instance.name = error.name;\r\n        }\r\n\r\n        return instance as InstanceType<T>;\r\n    }\r\n\r\n    static isInstance<T extends typeof UrbexError>(error: any): error is InstanceType<T> {\r\n        return error instanceof UrbexError;\r\n    }\r\n}\r\n\r\n/**\r\n * A TimeoutError is thrown when the request takes longer than the specified timeout.\r\n */\r\nexport class TimeoutError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"TimeoutError\";\r\n        this.message = message || \"The request timed out.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A NetworkError is thrown when the request fails to reach the server.\r\n */\r\nexport class NetworkError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"NetworkError\";\r\n        this.message = message || \"Failed to request the resource.\";\r\n    }\r\n}\r\n\r\n/**\r\n * A PipelineError is thrown when executing a pipeline fails.\r\n */\r\nexport class PipelineError extends UrbexError {\r\n    constructor(message?: string) {\r\n        super();\r\n\r\n        this.name = \"PipelineError\";\r\n        this.message = message || \"An error occurred while executing a pipeline.\";\r\n    }\r\n}\r\n","import type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type { ResolvableEntity } from \"../../types\";\r\n\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\n\r\ntype Resolve = (value: any) => void;\r\ntype Reject = (reason?: any) => void;\r\n\r\ninterface ResolvableBindings {\r\n    config: InternalConfiguration;\r\n    request: any;\r\n}\r\n\r\nexport function resolveRequest(\r\n    this: ResolvableBindings,\r\n    resolve: Resolve,\r\n    reject: Reject,\r\n    entity: ResolvableEntity\r\n): void {\r\n    const status = environment.isNode ? entity.response.statusCode : entity.response.status;\r\n\r\n    try {\r\n        const canResolve = this.config.resolveStatus(this.config, status);\r\n\r\n        if (canResolve) {\r\n            return resolve(entity);\r\n        }\r\n\r\n        const errorInstance: UrbexError = UrbexError.createErrorInstance.call(this, UrbexError);\r\n\r\n        errorInstance.status = status;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.request = this.request;\r\n\r\n        if (environment.isNode) {\r\n            errorInstance.message = entity.response.statusMessage;\r\n        } else {\r\n            errorInstance.message = entity.response.statusText;\r\n        }\r\n\r\n        if (!errorInstance.message) {\r\n            errorInstance.message = `Request failed with status code ${status}`;\r\n        }\r\n\r\n        return reject(errorInstance);\r\n    } catch (error) {\r\n        const errorInstance: UrbexError = UrbexError.createFromError.call(UrbexError, error);\r\n\r\n        errorInstance.message = error.message;\r\n        errorInstance.config = this.config;\r\n        errorInstance.request = this.request;\r\n        errorInstance.response = entity.response;\r\n        errorInstance.status = status;\r\n\r\n        return reject(errorInstance);\r\n    }\r\n}\r\n","import http from \"http\";\r\nimport https from \"https\";\r\nimport url from \"url\";\r\nimport zlib from \"zlib\";\r\nimport util from \"util\";\r\nimport stream from \"stream\";\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { combineStrings, isString, ensureTrailingToken, isFunction } from \"../../utils\";\r\n\r\nexport class NodeRequest implements UrbexRequestApi {\r\n    private getAgentFromProtocol(protocol: string): typeof http | typeof https {\r\n        if (protocol === \"https\") {\r\n            return https;\r\n        }\r\n\r\n        return http;\r\n    }\r\n\r\n    private handleDataProtocolRequest(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((resolve, reject) => {\r\n            resolve({\r\n                data: null,\r\n                request: null,\r\n                response: null\r\n            });\r\n        });\r\n    }\r\n\r\n    public async send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const agent = this.getAgentFromProtocol(config.url.protocol);\r\n\r\n            if (config.url.protocol === \"data\") {\r\n                return this.handleDataProtocolRequest(config);\r\n            }\r\n\r\n            if (!config.headers.has(\"Accept-Encoding\")) {\r\n                config.headers.set({ \"Accept-Encoding\": \"gzip, deflate, br\" });\r\n            }\r\n\r\n            const options: https.RequestOptions | url.URL = {\r\n                protocol: ensureTrailingToken(\":\", config.url.protocol),\r\n                href: config.url.href,\r\n                hostname: config.url.hostname,\r\n                path: combineStrings(\"\", config.url.pathname, config.url.search),\r\n                headers: config.headers.get(),\r\n                timeout: config.timeout\r\n            };\r\n\r\n            if (config.url.port) {\r\n                options.port = config.url.port;\r\n            }\r\n\r\n            const request = agent.request(options);\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onData(this: Buffer[], data: any): void {\r\n                this.push(data);\r\n            }\r\n\r\n            function onError(this: http.IncomingMessage, error: Error): void {\r\n                if (error instanceof UrbexError) {\r\n                    return _reject(error);\r\n                }\r\n\r\n                const errorInstance = createErrorInstance(NetworkError, error);\r\n                return _reject(errorInstance);\r\n            }\r\n\r\n            function onClose(this: http.IncomingMessage): void {\r\n                if (this.complete || this.aborted || this.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                this.destroy();\r\n                request.destroy();\r\n            }\r\n\r\n            function onEnd(this: Buffer[], response: http.IncomingMessage): void {\r\n                const body = Buffer.concat(this);\r\n\r\n                resolve({ data: body, request: request, response: response });\r\n                onClose.call(response);\r\n            }\r\n\r\n            function onTimeout(): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n\r\n                request.destroy(timeoutError);\r\n            }\r\n\r\n            function onResponse(response: http.IncomingMessage): void {\r\n                if (response.destroyed || request.destroyed) {\r\n                    return;\r\n                }\r\n\r\n                if (config.responseType === \"stream\") {\r\n                    return resolve({\r\n                        data: response,\r\n                        request: request,\r\n                        response: response\r\n                    });\r\n                }\r\n\r\n                const chunks: Buffer[] = [];\r\n\r\n                response.on(\"data\", (chunk) => {\r\n                    onData.call(chunks, chunk);\r\n                });\r\n\r\n                response.on(\"error\", (error) => {\r\n                    onError.call(response, error);\r\n                });\r\n\r\n                response.on(\"close\", () => {\r\n                    onClose.call(response);\r\n                });\r\n\r\n                response.on(\"end\", () => {\r\n                    onEnd.call(chunks, response);\r\n                });\r\n            }\r\n\r\n            request.on(\"response\", onResponse);\r\n\r\n            request.on(\"error\", (error) => {\r\n                onError.call(request, error);\r\n            });\r\n\r\n            if (config.timeout) {\r\n                request.on(\"timeout\", onTimeout);\r\n            }\r\n\r\n            request.end(config.data ?? undefined);\r\n        });\r\n    }\r\n}\r\n\r\nconst br = isFunction(zlib?.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;\r\nconst gzip = isFunction(zlib?.gunzip) ? util.promisify(zlib.gunzip) : null;\r\nconst deflate = isFunction(zlib?.inflate) ? util.promisify(zlib.inflate) : null;\r\nconst compress = isFunction(zlib?.createUnzip) ? util.promisify(zlib.createUnzip) : null;\r\n\r\nexport const DECODERS = { br, gzip, deflate, compress };\r\n","/* istanbul ignore file */\r\n\r\nimport type { InternalConfiguration } from \"../../exportable-types\";\r\nimport type {\r\n    DispatchedResponse,\r\n    UrbexRequestApi,\r\n    DispatchedAPIRequest,\r\n    ResponseTypes,\r\n    ResolvableEntity\r\n} from \"../../types\";\r\n\r\nimport { resolveRequest } from \"./resolve-request\";\r\nimport { UrbexError, TimeoutError, NetworkError } from \"../error\";\r\nimport { createEmptyScheme, uppercase, forEach, isUndefined, merge } from \"../../utils\";\r\n\r\ninterface BindableEventListener {\r\n    event: string;\r\n    listener: XMLEventListener;\r\n}\r\n\r\ntype BrowserResponseTypes = \"arraybuffer\" | \"blob\" | \"document\" | \"json\" | \"text\";\r\ntype XMLProgressEvent = ProgressEvent<EventTarget>;\r\n\r\ntype XMLEventListener = (this: XMLHttpRequest, ev: XMLProgressEvent) => void;\r\ntype XMLEventListeners = BindableEventListener[];\r\n\r\nconst BROWSER_RESPONSE_TYPES = [\"arraybuffer\", \"blob\", \"document\", \"json\", \"text\"];\r\n\r\nexport class BrowserRequest implements UrbexRequestApi {\r\n    public send(config: InternalConfiguration): DispatchedAPIRequest {\r\n        return new Promise((_resolve, _reject) => {\r\n            const request = new XMLHttpRequest();\r\n\r\n            function manageListeners(\r\n                listeners: XMLEventListeners,\r\n                method: \"addEventListener\" | \"removeEventListener\"\r\n            ) {\r\n                for (const { event, listener } of listeners) {\r\n                    request[method](event, listener);\r\n                }\r\n            }\r\n\r\n            request.open(uppercase(config.method), config.url.href, true);\r\n\r\n            if (\r\n                BROWSER_RESPONSE_TYPES.includes(config.responseType) &&\r\n                config.responseType !== \"json\"\r\n            ) {\r\n                request.responseType = config.responseType as BrowserResponseTypes;\r\n            }\r\n\r\n            if (isUndefined(config.data)) {\r\n                config.headers.delete(\"Content-Type\");\r\n            }\r\n\r\n            forEach(config.headers.get(), request.setRequestHeader.bind(request));\r\n\r\n            if (config.timeout) {\r\n                request.timeout = config.timeout;\r\n            }\r\n\r\n            function resolve(response: ResolvableEntity): void {\r\n                return resolveRequest.call({ config, request }, _resolve, _reject, response);\r\n            }\r\n\r\n            function createErrorInstance<T extends typeof UrbexError>(\r\n                instance: T,\r\n                error: Error\r\n            ): InstanceType<T> {\r\n                const errorInstance: InstanceType<T> = UrbexError.createFromError.call(\r\n                    instance,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = request;\r\n\r\n                return errorInstance;\r\n            }\r\n\r\n            function onTimeout(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const error = new Error(`Timeout of ${config.timeout}ms exceeded`);\r\n                const timeoutError = createErrorInstance(TimeoutError, error);\r\n                _reject(timeoutError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onAbort(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                const abortError = createErrorInstance(\r\n                    UrbexError,\r\n                    new Error(\"Request was aborted\")\r\n                );\r\n                abortError.message = \"The request was aborted.\";\r\n                _reject(abortError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onError(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // https://stackoverflow.com/questions/45067892/xmlhttprequest-onerror-handler-use-case\r\n\r\n                const networkError = createErrorInstance(NetworkError, new Error(\"Network Error\"));\r\n                _reject(networkError);\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            function onLoad(this: XMLHttpRequest, ev: XMLProgressEvent): void {\r\n                // Uncaught DOMException: XMLHttpRequest.responseText\r\n                // getter: responseText is only available if responseType is '' or 'text'.\r\n                // thats why the below function exists\r\n\r\n                function getResponse() {\r\n                    if (request.responseType === \"document\") {\r\n                        return request.responseXML;\r\n                    }\r\n\r\n                    if (!request.responseType || request.responseType === \"text\") {\r\n                        return request.responseText;\r\n                    }\r\n\r\n                    return request.response;\r\n                }\r\n\r\n                resolve({\r\n                    data: getResponse(),\r\n                    request: request,\r\n                    response: {\r\n                        status: request.status,\r\n                        statusText: request.statusText,\r\n                        headers: request.getAllResponseHeaders()\r\n                    }\r\n                });\r\n\r\n                manageListeners(listeners, \"removeEventListener\");\r\n            }\r\n\r\n            const listeners: XMLEventListeners = [\r\n                { event: \"timeout\", listener: onTimeout },\r\n                { event: \"abort\", listener: onAbort },\r\n                { event: \"error\", listener: onError },\r\n                { event: \"load\", listener: onLoad }\r\n            ];\r\n\r\n            manageListeners(listeners, \"addEventListener\");\r\n\r\n            // https://plnkr.co/edit/ycQbBr0vr7ceUP2p6PHy?p=preview&preview\r\n\r\n            request.onreadystatechange = function () {};\r\n\r\n            request.send(config.data);\r\n        });\r\n    }\r\n}\r\n\r\n// this is here because when building for the browser, the http api\r\n// is replaced with the xhr api. And so it doesn't throw errors\r\n// this is here for safety\r\nexport const DECODERS = createEmptyScheme([\"br\", \"gzip\", \"deflate\", \"compress\"]);\r\n","import { mutate, argumentIsNotProvided, isObject, forEach, isString } from \"../utils\";\r\nimport { PipelineError } from \"../core/error\";\r\n\r\ntype ReturnType<T> = T extends (config: any) => infer R ? R : any;\r\ntype Parameters<T extends Function> = T extends (config: infer P) => any ? P : never;\r\n\r\nexport class PipelineExecutor<T extends Function> {\r\n    private $executor: T = null;\r\n\r\n    constructor(executor: T) {\r\n        this.$executor = executor;\r\n    }\r\n\r\n    public static async process<T, D extends Function>(\r\n        config: T,\r\n        pipelines: PipelineExecutor<D>[]\r\n    ): Promise<void> {\r\n        for (const pipeline of pipelines) {\r\n            if (!(pipeline instanceof PipelineExecutor)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid pipeline to be passed to the `process` method.\"\r\n                );\r\n            }\r\n\r\n            const pipelineResult = await pipeline.execute(config as Parameters<D>);\r\n\r\n            if (!isObject(pipelineResult)) {\r\n                throw new PipelineError(\r\n                    \"Urbex expected a valid configuration to be returned from a pipeline.\"\r\n                );\r\n            }\r\n\r\n            config = mutate(config, () => {\r\n                return pipelineResult;\r\n            });\r\n        }\r\n    }\r\n\r\n    public async execute(config: Parameters<T>): Promise<ReturnType<T>> {\r\n        return this.$executor(config);\r\n    }\r\n}\r\n","import type { Headers, HeaderValues, NormalizedHeaders } from \"../types\";\r\n\r\nimport {\r\n    isArray,\r\n    isObject,\r\n    isUndefined,\r\n    hasOwnProperty,\r\n    forEach,\r\n    merge,\r\n    capitalize,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isString,\r\n    lowercase,\r\n    stringReplacer\r\n} from \"../utils\";\r\nimport { debug } from \"../debug\";\r\nimport { environment } from \"../environment\";\r\n\r\nconst DEFAULT_BROWSER_HEADERS = {\r\n    \"Content-Type\": \"application/json\"\r\n};\r\n\r\nconst DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {\r\n    \"User-Agent\": `UrbexClient (Node.js ${environment.process.version}; ${environment.process.platform})`\r\n});\r\n\r\nfunction removeNewLines(value: string): string {\r\n    return stringReplacer(value, \"\\n\", \"\");\r\n}\r\n\r\nfunction parseHeaderKey(key: string): string {\r\n    if (key) {\r\n        const format = formatHeaderKey(lowercase(key)).trim();\r\n        return removeNewLines(format);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    return undefined;\r\n}\r\n\r\nfunction parseHeaderValue(value: HeaderValues): string {\r\n    if (isUndefined(value) || value === false || value === null) {\r\n        return undefined;\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isArray(value)) {\r\n        return value.join(\", \");\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    if (isObject(value)) {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    const newValue = value.toString().trim();\r\n    return removeNewLines(newValue);\r\n}\r\n\r\nfunction normalizeHeaders(headers: Headers): NormalizedHeaders {\r\n    const newHeaders: NormalizedHeaders = {};\r\n\r\n    forEach(headers, (key, value) => {\r\n        if (isUndefined(key) || isUndefined(value)) {\r\n            return;\r\n        }\r\n\r\n        const normalizedKey = parseHeaderKey(key);\r\n        const normalizedValue = parseHeaderValue(value);\r\n\r\n        if (normalizedKey && normalizedValue) {\r\n            newHeaders[normalizedKey] = normalizedValue;\r\n        }\r\n    });\r\n\r\n    return newHeaders;\r\n}\r\n\r\nfunction formatHeaderKey(key: string): string {\r\n    // split by the dash\r\n    // capitalize each word\r\n    // join the words back together\r\n\r\n    const words = key.split(\"-\");\r\n    const formattedWords = words.map((word) => {\r\n        const parsedWord = removeNewLines(word).trim();\r\n\r\n        if (parsedWord) {\r\n            return capitalize(parsedWord);\r\n        }\r\n    });\r\n    return formattedWords.join(\"-\");\r\n}\r\n\r\nexport class UrbexHeaders {\r\n    protected $headers: NormalizedHeaders = {};\r\n\r\n    constructor(headers?: Headers, withDefaults = true) {\r\n        if (withDefaults) {\r\n            this.set(this.defaults, false);\r\n        }\r\n\r\n        if (isObject(headers) && !isEmpty(headers)) {\r\n            this.set(headers, withDefaults);\r\n        }\r\n    }\r\n\r\n    static construct(headers: Headers = {}, withDefaults = true): UrbexHeaders {\r\n        return new UrbexHeaders(headers, withDefaults);\r\n    }\r\n\r\n    /**\r\n     * Parse a headers string into an object\r\n     */\r\n    static parse(headers: string): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isString(headers)) {\r\n            return {};\r\n        }\r\n\r\n        const parsedHeaders: NormalizedHeaders = {};\r\n\r\n        const lines = headers.split(\"\\r\");\r\n\r\n        forEach(lines, (index, pair) => {\r\n            const [pairKey, pairValue] = pair.toString().split(\":\");\r\n\r\n            const key = parseHeaderKey(pairKey);\r\n            const value = parseHeaderValue(pairValue);\r\n\r\n            if (key && value) {\r\n                parsedHeaders[key] = value;\r\n            }\r\n        });\r\n\r\n        return parsedHeaders;\r\n    }\r\n\r\n    get defaults(): typeof DEFAULT_NODE_HEADERS | typeof DEFAULT_BROWSER_HEADERS {\r\n        return environment.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;\r\n    }\r\n\r\n    /**\r\n     * Set a header configuration to use for all requests made by the current\r\n     * instance of the Urbex client\r\n     *\r\n     * Setting a configuration will merge with any existing configuration.\r\n     * Optionally, you can pass a boolean to clear the existing configuration\r\n     *\r\n     * @param headers The headers to set\r\n     * @param forceMerge Whether to merge the headers with the existing configuration\r\n     */\r\n    public set(headers?: Headers, forceMerge = true): Headers {\r\n        if (!isObject(headers)) {\r\n            debug(\"error\", `Attempted to set headers with a non-object value: ${typeof headers}`);\r\n            return headers;\r\n        }\r\n\r\n        const normalizedHeaders = this.normalize(headers);\r\n        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;\r\n\r\n        return (this.$headers = merged);\r\n    }\r\n    /**\r\n     * Get the current headers object\r\n     */\r\n    public get(): NormalizedHeaders {\r\n        return this.$headers;\r\n    }\r\n\r\n    /**\r\n     * Whether the headers object contains a given header\r\n     */\r\n    public has(key: string): boolean {\r\n        return hasOwnProperty(this.$headers, parseHeaderKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete a header from the headers object\r\n     */\r\n    public delete(key: string): void {\r\n        forEach(this.$headers, (headerKey) => {\r\n            if (headerKey.toLowerCase() === key.toLowerCase()) {\r\n                delete this.$headers[headerKey];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     *\r\n     * Clear all headers that have been set\r\n     * @param empty Whether to empty the headers object\r\n     *\r\n     */\r\n    public clear(empty = false): void {\r\n        this.$headers = {};\r\n\r\n        if (!empty) {\r\n            this.set(this.defaults, false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Normalize an incoming headers object\r\n     */\r\n    public normalize(headers: Headers): NormalizedHeaders {\r\n        if (argumentIsNotProvided(headers) || !isObject(headers)) {\r\n            return {};\r\n        }\r\n\r\n        return normalizeHeaders(headers);\r\n    }\r\n}\r\n","type DebugType = \"log\" | \"warn\" | \"error\";\r\n\r\nexport function debug(type: DebugType, message: string): void {\r\n    console[type](`[urbex] ${message}`);\r\n}\r\n","import { CacheClock } from \"cache-clock\";\r\n\r\nimport type { UrbexContext } from \"../../environment\";\r\nimport type { InternalConfiguration, UrbexResponse } from \"../../exportable-types\";\r\nimport type { DispatchedResponse, UrbexRequestApi } from \"../../types\";\r\n\r\nimport { NodeRequest } from \"./http\";\r\nimport { BrowserRequest } from \"./xhr\";\r\nimport { startRequest } from \"./conclude\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexError } from \"../error\";\r\nimport { isUndefined } from \"../../utils\";\r\nimport { DEFAULT_CLIENT_OPTIONS } from \"../constants\";\r\n\r\nexport class RequestApi {\r\n    /**\r\n     * The internal api that is used to send requests.\r\n     */\r\n    protected $api: UrbexRequestApi;\r\n    /**\r\n     * An isolated cache module that is used to cache requests.\r\n     */\r\n    protected $cache: CacheClock;\r\n\r\n    constructor() {\r\n        this.register(environment.context);\r\n\r\n        this.$cache = new CacheClock({\r\n            autoStart: false,\r\n            debug: false\r\n        });\r\n    }\r\n\r\n    private register(context: UrbexContext) {\r\n        if (context === \"browser\") {\r\n            this.$api = new BrowserRequest();\r\n            return;\r\n        }\r\n\r\n        if (context === \"node\") {\r\n            this.$api = new NodeRequest();\r\n            return;\r\n        }\r\n\r\n        throw new Error(\r\n            `Urbex expected a valid context to register a request api, but got ${context}.`\r\n        );\r\n    }\r\n\r\n    protected async dispatchRequest(config: InternalConfiguration): DispatchedResponse {\r\n        try {\r\n            const configuration = config;\r\n            const concludeRequest = await startRequest(configuration);\r\n\r\n            const isCacheEnabled = configuration.cache && configuration.cache.enabled;\r\n\r\n            if (isCacheEnabled) {\r\n                const cacheKey = this.$cache.getCacheKey(configuration.url.href);\r\n                const entity = this.$cache.get(cacheKey, true);\r\n\r\n                if (entity) {\r\n                    const result = await concludeRequest({\r\n                        data: entity.v,\r\n                        request: null,\r\n                        response: null,\r\n                        cache: {\r\n                            key: cacheKey,\r\n                            pulled: true,\r\n                            hit: true,\r\n                            stored: false\r\n                        }\r\n                    });\r\n\r\n                    return Promise.resolve(result);\r\n                }\r\n            }\r\n\r\n            const response = await this.$api.send(configuration);\r\n            const result = await concludeRequest(response);\r\n\r\n            if (isCacheEnabled && !isUndefined(result.data)) {\r\n                this.$cache.set(configuration.url.href, result.data);\r\n\r\n                result.cache.key = this.$cache.getCacheKey(configuration.url.href);\r\n                result.cache.stored = true;\r\n            }\r\n\r\n            result.cache.hit = isCacheEnabled;\r\n\r\n            return Promise.resolve(result);\r\n        } catch (error: any) {\r\n            if (UrbexError.isInstance(error)) {\r\n                return Promise.reject(error);\r\n            }\r\n\r\n            const internalError = UrbexError.createFromError.call(UrbexError, error);\r\n            internalError.message = error.message;\r\n            return Promise.reject(internalError);\r\n        }\r\n    }\r\n}\r\n","import type {\r\n    InternalConfiguration,\r\n    UrbexResponse,\r\n    RequestExecutor,\r\n    ResponseExecutor\r\n} from \"../../exportable-types\";\r\nimport type { DispatchedResponse, RequestAPIResponse } from \"../../types\";\r\n\r\nimport { PipelineExecutor } from \"../pipelines\";\r\nimport { deepMerge, isEmpty, deepClone, mutate } from \"../../utils\";\r\nimport { DEFAULT_URBEX_RESPONSE } from \"../constants\";\r\nimport { environment } from \"../../environment\";\r\nimport { UrbexHeaders } from \"../../core/headers\";\r\nimport { UrbexError, PipelineError } from \"../error\";\r\n\r\ntype ConcludeRequest = (config: RequestAPIResponse) => Promise<DispatchedResponse>;\r\n\r\nexport async function startRequest(config: InternalConfiguration): Promise<ConcludeRequest> {\r\n    const startTime = Date.now();\r\n    const timestamp = new Date().toISOString();\r\n    const clonedResponse = deepClone(DEFAULT_URBEX_RESPONSE);\r\n\r\n    if (!isEmpty(config.pipelines.request)) {\r\n        // loop over the request pipelines\r\n        // each pipeline is a Promise that returns a new config\r\n        // each new config is passed to the next pipeline\r\n        // the very last config will mutate the `config` parameter\r\n\r\n        try {\r\n            await PipelineExecutor.process<InternalConfiguration, RequestExecutor>(\r\n                config,\r\n                config.pipelines.request\r\n            );\r\n        } catch (error) {\r\n            const errorInstance: UrbexError = UrbexError.createFromError.call(PipelineError, error);\r\n            errorInstance.config = config;\r\n            return Promise.reject(errorInstance);\r\n        }\r\n    }\r\n\r\n    return async function concludeRequest(result): Promise<DispatchedResponse> {\r\n        const incomingResult: UrbexResponse = deepMerge(clonedResponse, {\r\n            data: result.data,\r\n            config: config,\r\n            request: result.request || {},\r\n            response: result.response || {},\r\n            timestamp: timestamp,\r\n            responseType: config.responseType,\r\n            cache: result.cache || {}\r\n        });\r\n\r\n        if (incomingResult.cache && incomingResult.cache.hit) {\r\n            const statusCode = 200;\r\n            const statusText = \"Pulled from internal cache.\";\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.response.statusCode = statusCode;\r\n                incomingResult.response.statusMessage = statusText;\r\n            } else {\r\n                incomingResult.response.status = statusCode;\r\n                incomingResult.response.statusText = statusText;\r\n            }\r\n        }\r\n\r\n        if (incomingResult.response) {\r\n            incomingResult.headers = incomingResult.response.headers;\r\n\r\n            if (environment.isNode) {\r\n                incomingResult.status = incomingResult.response.statusCode;\r\n                incomingResult.statusText = incomingResult.response.statusMessage;\r\n            } else {\r\n                const parsedHeaders = UrbexHeaders.parse(incomingResult.headers);\r\n\r\n                incomingResult.headers = parsedHeaders;\r\n\r\n                incomingResult.status = incomingResult.response.status;\r\n                incomingResult.statusText = incomingResult.response.statusText;\r\n            }\r\n        }\r\n\r\n        if (!isEmpty(config.pipelines.response)) {\r\n            try {\r\n                await PipelineExecutor.process<UrbexResponse, ResponseExecutor>(\r\n                    incomingResult,\r\n                    config.pipelines.response\r\n                );\r\n            } catch (error) {\r\n                const errorInstance: UrbexError = UrbexError.createFromError.call(\r\n                    PipelineError,\r\n                    error\r\n                );\r\n                errorInstance.config = config;\r\n                errorInstance.request = incomingResult.request;\r\n                errorInstance.response = incomingResult.response;\r\n                errorInstance.status = incomingResult.status;\r\n                return Promise.reject(errorInstance);\r\n            }\r\n        }\r\n\r\n        const endTime = Date.now();\r\n        const duration = endTime - startTime;\r\n\r\n        incomingResult.duration = duration;\r\n        return Promise.resolve(incomingResult);\r\n    };\r\n}\r\n","import type { RequestExecutor, ResponseExecutor } from \"../exportable-types\";\r\n\r\nimport { REQUEST_BODY_METHODS } from \"./constants\";\r\nimport { PipelineExecutor } from \"./pipelines\";\r\nimport { environment } from \"../environment\";\r\nimport { DECODERS } from \"./api/http\";\r\nimport { safeJSONParse, uppercase } from \"../utils\";\r\n\r\nconst SKIPPABLE_RESPONSE_TYPES = [\"stream\", \"raw\"];\r\n\r\nexport const transformRequestData = new PipelineExecutor<RequestExecutor>((config) => {\r\n    if (REQUEST_BODY_METHODS.includes(uppercase(config.method))) {\r\n        config.headers.set({\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n        });\r\n    } else {\r\n        config.data = undefined;\r\n    }\r\n\r\n    // check the config.data and then change the content type header\r\n\r\n    return Promise.resolve(config);\r\n});\r\n\r\n// the below `decodeResponseData` is only used for NodeJS\r\n\r\nexport const decodeResponseData = new PipelineExecutor<ResponseExecutor>(async (response) => {\r\n    const { responseType, maxContentLength } = response.config;\r\n\r\n    if (SKIPPABLE_RESPONSE_TYPES.includes(responseType) || response.cache.pulled) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    const encoding = response.headers[\"content-encoding\"];\r\n\r\n    if (Buffer.isBuffer(response.data) && response.data.length) {\r\n        if (encoding) {\r\n            const decoder = DECODERS[encoding];\r\n\r\n            if (decoder) {\r\n                const decompressed = await decoder(response.data);\r\n\r\n                if (maxContentLength > -1 || maxContentLength !== Infinity) {\r\n                    if (decompressed.length > maxContentLength) {\r\n                        throw new Error(\r\n                            `Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`\r\n                        );\r\n                    }\r\n                }\r\n\r\n                response.data = decompressed;\r\n            }\r\n        }\r\n    } else {\r\n        response.data = null;\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n\r\nexport const transformResponseData = new PipelineExecutor<ResponseExecutor>((response) => {\r\n    const { responseType, responseEncoding } = response.config;\r\n\r\n    if (\r\n        SKIPPABLE_RESPONSE_TYPES.includes(responseType) ||\r\n        responseType === \"arraybuffer\" ||\r\n        response.cache.pulled\r\n    ) {\r\n        return Promise.resolve(response);\r\n    }\r\n\r\n    if (response.data) {\r\n        let data = response.data;\r\n\r\n        if (environment.isNode) {\r\n            // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows\r\n\r\n            data = response.data.toString(responseEncoding);\r\n        }\r\n\r\n        if (responseType === \"json\") {\r\n            response.data = safeJSONParse(data, true);\r\n        } else {\r\n            response.data = data;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n});\r\n","import type { InternalConfiguration, UrbexConfig, UrbexURL } from \"../exportable-types\";\r\n\r\nimport { UrbexHeaders } from \"./headers\";\r\nimport { transformRequestData, transformResponseData, decodeResponseData } from \"./transformers\";\r\nimport { environment } from \"../environment\";\r\nimport { URLParser } from \"./parsers/url-parser\";\r\nimport {\r\n    isObject,\r\n    merge,\r\n    deepMerge,\r\n    clone,\r\n    deepClone,\r\n    hasOwnProperty,\r\n    isString,\r\n    extractMatchFromRegExp,\r\n    uppercase,\r\n    argumentIsNotProvided,\r\n    isEmpty,\r\n    isFunction\r\n} from \"../utils\";\r\nimport { METHODS } from \"./constants\";\r\nimport {\r\n    DEFAULT_CLIENT_OPTIONS,\r\n    DEFAULT_PIPELINE_EXECUTORS,\r\n    DEFAULT_URL_COMPONENT\r\n} from \"./constants\";\r\n\r\nfunction isPathname(pathname: string): boolean {\r\n    if (!pathname.startsWith(\"//\") && pathname.startsWith(\"/\")) {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction manageURLComponent(this: URLParser, component: UrbexURL, allowEndpoints: boolean): void {\r\n    if (isString(component)) {\r\n        const hasPathname = isPathname(component);\r\n\r\n        if (hasPathname) {\r\n            if (allowEndpoints) {\r\n                this.pathname = component;\r\n            } else {\r\n                throw new Error(\r\n                    \"A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.\"\r\n                );\r\n            }\r\n        } else {\r\n            this.parse(component);\r\n        }\r\n    } else {\r\n        // the serializer always uses the origin if passed\r\n        // however this conflicts if the configuration method\r\n        // is called multiple times attempting to change\r\n        // components of the URL. By default, the origin will always\r\n        // be present since it was parsed previously and will fail to\r\n        // adjust the other components.\r\n\r\n        // to fix this, if the origin is not passed, we will\r\n        // set it to an empty string so that the serializer\r\n        // will not use it.\r\n\r\n        if (component.origin === undefined) {\r\n            component.origin = \"\";\r\n        }\r\n\r\n        component.href ? this.parse(component.href) : this.set(component).serialize(this.toJSON());\r\n    }\r\n}\r\n\r\nexport class RequestConfig {\r\n    private $config: InternalConfiguration;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        this.setup();\r\n\r\n        /* istanbul ignore if */\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.set(this.createConfigurationObject(config, true));\r\n        }\r\n    }\r\n\r\n    private setup(): void {\r\n        const envComponent = environment.getEnvironmentComponent();\r\n\r\n        const pipelines = deepClone(DEFAULT_PIPELINE_EXECUTORS);\r\n\r\n        pipelines.request.push(transformRequestData);\r\n        pipelines.response.push(transformResponseData);\r\n\r\n        if (environment.isNode) {\r\n            pipelines.response.unshift(decodeResponseData);\r\n        }\r\n\r\n        const options = deepClone(DEFAULT_CLIENT_OPTIONS);\r\n\r\n        const configuration = deepMerge(options, {\r\n            url: envComponent,\r\n            headers: new UrbexHeaders(),\r\n            pipelines: pipelines\r\n        });\r\n\r\n        this.set(configuration);\r\n    }\r\n\r\n    /* istanbul ignore next */\r\n    public defaultConfig(): InternalConfiguration {\r\n        return merge(DEFAULT_CLIENT_OPTIONS, {\r\n            url: environment.getEnvironmentComponent(),\r\n            headers: new UrbexHeaders()\r\n        });\r\n    }\r\n\r\n    public createConfigurationObject(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): InternalConfiguration {\r\n        const parsed = this.parseIncomingConfig(config, allowEndpoints);\r\n        const merged = this.merge(parsed);\r\n\r\n        return merged;\r\n    }\r\n\r\n    public parseIncomingConfig(\r\n        config: UrbexConfig,\r\n        allowEndpoints: boolean\r\n    ): Partial<InternalConfiguration> {\r\n        if (argumentIsNotProvided(config) || !isObject(config)) {\r\n            throw new Error(\"The configuration must be an object with valid properties.\");\r\n        }\r\n\r\n        if (isEmpty(config)) {\r\n            return {};\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const configuration = clone(config);\r\n\r\n        const clonedUrl = clone(currentConfig.url.toJSON());\r\n        const parser = new URLParser();\r\n\r\n        parser.set(clonedUrl);\r\n\r\n        if (hasOwnProperty(configuration, \"url\")) {\r\n            const url = configuration.url;\r\n\r\n            if (!isString(url) && !isObject(url)) {\r\n                throw new Error(\"The url property must be a string or an object.\");\r\n            }\r\n\r\n            manageURLComponent.call(parser, url, allowEndpoints);\r\n        }\r\n\r\n        if (hasOwnProperty(configuration, \"method\")) {\r\n            const method = uppercase(configuration.method);\r\n\r\n            if (!METHODS.includes(method)) {\r\n                throw new Error(`The method ${method} is not a valid HTTP method.`);\r\n            }\r\n\r\n            configuration.method = method;\r\n        }\r\n\r\n        const timeout = parseInt(configuration.timeout?.toString(), 10);\r\n\r\n        if (isNaN(timeout)) {\r\n            configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;\r\n        }\r\n\r\n        const maxContentLength = parseInt(configuration.maxContentLength?.toString(), 10);\r\n\r\n        if (isNaN(maxContentLength)) {\r\n            configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;\r\n        }\r\n\r\n        if (!isFunction(config.resolveStatus)) {\r\n            config.resolveStatus = DEFAULT_CLIENT_OPTIONS.resolveStatus;\r\n        }\r\n\r\n        const headers = UrbexHeaders.construct(configuration.headers, true);\r\n\r\n        configuration.headers = null;\r\n        configuration.url = null;\r\n\r\n        return merge<UrbexConfig, Partial<InternalConfiguration>>(configuration, {\r\n            headers: headers,\r\n            url: parser\r\n        });\r\n    }\r\n\r\n    public set(config: InternalConfiguration): InternalConfiguration {\r\n        this.$config = config;\r\n        return config;\r\n    }\r\n\r\n    public merge(\r\n        config?: InternalConfiguration | Partial<InternalConfiguration>\r\n    ): InternalConfiguration {\r\n        if (argumentIsNotProvided(config) || !isObject(config) || isEmpty(config)) {\r\n            return this.get();\r\n        }\r\n\r\n        const currentConfig = this.get();\r\n        const incomingHeaders = config.headers?.get() ?? {};\r\n        const incomingComponent = config.url?.toJSON() ?? {};\r\n\r\n        const mergedHeaders = merge(currentConfig.headers.get(), incomingHeaders);\r\n        const mergedComponent = merge(currentConfig.url.toJSON(), incomingComponent);\r\n\r\n        const merged = deepMerge(currentConfig, config);\r\n\r\n        const headersObject = UrbexHeaders.construct(mergedHeaders);\r\n        const componentObject = new URLParser();\r\n\r\n        componentObject.set(mergedComponent);\r\n\r\n        return merge<InternalConfiguration, Partial<InternalConfiguration>>(merged, {\r\n            headers: headersObject,\r\n            url: componentObject\r\n        });\r\n    }\r\n\r\n    public get(): InternalConfiguration {\r\n        return this.$config;\r\n    }\r\n\r\n    /**\r\n     * Reset the configuration to its default state.\r\n     */\r\n    public reset() {\r\n        this.setup();\r\n    }\r\n}\r\n","import type { CacheClock } from \"cache-clock\";\r\nimport type {\r\n    Methods,\r\n    MethodsLower,\r\n    MethodsUpper,\r\n    RequestUrlPath,\r\n    DispatchedResponse,\r\n    PipelineExecutorsManager\r\n} from \"../types\";\r\nimport type { UrbexURL, UrbexConfig, InternalConfiguration } from \"../exportable-types\";\r\n\r\nimport { RequestApi } from \"./api/request-api\";\r\nimport { RequestConfig } from \"./request-config\";\r\nimport { UrbexError } from \"./error\";\r\nimport {\r\n    deepMerge,\r\n    merge,\r\n    clone,\r\n    isString,\r\n    isObject,\r\n    argumentIsNotProvided,\r\n    hasOwnProperty,\r\n    stringReplacer,\r\n    forEach,\r\n    isUndefined,\r\n    uppercase,\r\n    isEmpty\r\n} from \"../utils\";\r\n\r\ntype UrbexDirectRequest = Omit<UrbexConfig, \"data\" | \"url\" | \"cache\">;\r\ntype UrbexMethodRequest = Omit<UrbexDirectRequest, \"method\">;\r\n\r\nexport interface UrbexClient {\r\n    /**\r\n     * Send a GET request.\r\n     */\r\n    get(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a POST request.\r\n     */\r\n    post(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PUT request.\r\n     */\r\n    put(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a PATCH request.\r\n     */\r\n    patch(url: UrbexURL, data?: any, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a DELETE request.\r\n     */\r\n    delete(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a HEAD request.\r\n     */\r\n    head(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n    /**\r\n     * Send a OPTIONS request.\r\n     */\r\n    options(url: UrbexURL, config?: UrbexMethodRequest): DispatchedResponse;\r\n}\r\n\r\nfunction createMethodConfig(method: Methods, uri: UrbexURL, config: UrbexConfig): UrbexConfig {\r\n    if (argumentIsNotProvided(uri)) {\r\n        throw new Error(\r\n            \"Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.\"\r\n        );\r\n    }\r\n\r\n    return merge(config, { url: uri, method: method });\r\n}\r\n\r\nexport class UrbexClient extends RequestApi {\r\n    private $config: RequestConfig;\r\n\r\n    constructor(config?: UrbexConfig) {\r\n        super();\r\n\r\n        this.$config = new RequestConfig();\r\n\r\n        if (isObject(config) && !isEmpty(config)) {\r\n            this.configure(config);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Creates a new instance of the UrbexClient.\r\n     */\r\n    static create(config?: UrbexConfig): UrbexClient {\r\n        return new UrbexClient(config);\r\n    }\r\n\r\n    /**\r\n     * Current, and most up-to-date configuration of the UrbexClient.\r\n     */\r\n    public get config(): Readonly<InternalConfiguration> {\r\n        return this.$config.get();\r\n    }\r\n\r\n    /**\r\n     * The internal cache module.\r\n     */\r\n    public get cache(): Readonly<CacheClock> {\r\n        return this.$cache;\r\n    }\r\n\r\n    /**\r\n     * Configures the UrbexClient. You are free to call this method as\r\n     * many times as you want. All configurations will be merged together.\r\n     *\r\n     * @param config The configuration to use.\r\n     */\r\n    public configure(config: UrbexConfig): void {\r\n        const configuration = this.$config.createConfigurationObject(config, false);\r\n        this.$config.set(configuration);\r\n\r\n        const cache = this.$cache;\r\n\r\n        function stopCache(): void {\r\n            if (cache) {\r\n                cache.clear();\r\n\r\n                if (cache.isRunning) {\r\n                    cache.stop();\r\n                }\r\n            }\r\n        }\r\n\r\n        function startCache(): void {\r\n            if (!cache || !cache.isRunning) {\r\n                cache.start();\r\n            }\r\n        }\r\n\r\n        if (isEmpty(configuration.cache)) {\r\n            stopCache();\r\n        } else {\r\n            cache.configure(configuration.cache);\r\n\r\n            if (configuration.cache.enabled) {\r\n                startCache();\r\n            } else if (configuration.cache.enabled === false) {\r\n                stopCache();\r\n            }\r\n        }\r\n    }\r\n\r\n    public send(config: UrbexConfig = {}): DispatchedResponse {\r\n        const configuration = this.$config.parseIncomingConfig(config, true);\r\n        const merged = this.$config.merge(configuration);\r\n\r\n        return this.dispatchRequest(merged);\r\n    }\r\n\r\n    /**\r\n     * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response\r\n     */\r\n    public injectPipeline(): void {}\r\n\r\n    /**\r\n     * Eject a pipeline from the UrbexClient.\r\n     */\r\n    public ejectPipeline(): void {}\r\n\r\n    /**\r\n     * When a response is received, the UrbexClient will actively push out the response to all active\r\n     * subscriptions\r\n     */\r\n    public subscribe() {}\r\n\r\n    public unsubscribe(): void {}\r\n\r\n    /**\r\n     * Reset the configuration to default values.\r\n     */\r\n    public reset(): void {\r\n        if (this.$cache) {\r\n            this.$cache.clear();\r\n\r\n            if (this.$cache.isRunning) {\r\n                this.$cache.stop();\r\n            }\r\n        }\r\n\r\n        this.$config.reset();\r\n    }\r\n}\r\n\r\nforEach([\"delete\", \"get\", \"head\", \"options\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        return this.send(createMethodConfig(uppercase(value), url, config));\r\n    };\r\n});\r\n\r\nforEach([\"post\", \"put\", \"patch\"], (_, value: MethodsLower) => {\r\n    UrbexClient.prototype[value] = function (\r\n        this: UrbexClient,\r\n        url: UrbexURL,\r\n        data?: any,\r\n        config?: UrbexMethodRequest\r\n    ) {\r\n        function combineIncomingConfig(): UrbexConfig {\r\n            if (isUndefined(data)) {\r\n                return data;\r\n            }\r\n\r\n            /* istanbul ignore next */\r\n            if (isObject(config)) {\r\n                return merge(config, { data: data });\r\n            } else {\r\n                return { data };\r\n            }\r\n        }\r\n\r\n        const configuration = combineIncomingConfig();\r\n\r\n        return this.send(createMethodConfig(uppercase(value), url, configuration));\r\n    };\r\n});\r\n\r\nexport function isUrbexClient(client: unknown): client is UrbexClient {\r\n    return client instanceof UrbexClient;\r\n}\r\n","import type { UrbexConfig } from \"./exportable-types\";\r\n\r\nimport { environment, Environment } from \"./environment\";\r\nimport { UrbexClient, isUrbexClient } from \"./core/urbex\";\r\nimport { PipelineExecutor } from \"./core/pipelines\";\r\n\r\n/**\r\n * The extended client that has other methods attached to it\r\n * that are not part of the core client.\r\n */\r\nexport interface ExtendedUrbexClient extends UrbexClient {\r\n    /**\r\n     * Create a new isolated instance of the Urbex client\r\n     *\r\n     * Any existing configuration will be copied to the new\r\n     * instance. Furthermore, changes made to the new instance\r\n     * will not affect the original instance\r\n     */\r\n    isolateClient(config?: UrbexConfig): UrbexClient;\r\n    /**\r\n     *\r\n     * TypeScript safe guard to check if an object is an instance of UrbexClient\r\n     */\r\n    isUrbexClient(client: unknown): client is UrbexClient;\r\n    /**\r\n     * The underlying UrbexClient class which can be used to create new instances\r\n     *\r\n     * Recommended to use `isolateClient` instead\r\n     */\r\n    Client: typeof UrbexClient;\r\n    /**\r\n     * The current environment of the project\r\n     */\r\n    environment: Environment;\r\n}\r\n\r\nfunction createClient(): ExtendedUrbexClient {\r\n    const client = UrbexClient.create();\r\n    const extendedClient = client as ExtendedUrbexClient;\r\n\r\n    extendedClient.isolateClient = UrbexClient.create;\r\n    extendedClient.environment = environment;\r\n    extendedClient.isUrbexClient = isUrbexClient;\r\n    extendedClient.Client = UrbexClient;\r\n\r\n    return extendedClient;\r\n}\r\n\r\nconst urbex = createClient();\r\n\r\nexport * from \"./exportable-types\";\r\nexport * from \"./core/pipelines\";\r\n// export * from \"./core/headers\";\r\nexport * from \"./core/parsers/url-parser\";\r\nexport * from \"./core/error\";\r\n\r\nexport default urbex;\r\n","import urbex, {\r\n    PipelineExecutor,\r\n    URLParser,\r\n    UrbexError,\r\n    TimeoutError,\r\n    NetworkError,\r\n    PipelineError\r\n} from \"./lib/urbex\";\r\n\r\n// since this package has a named export and a default export, rollup\r\n// uses `output.exports: \"named\"` to make the named export the default\r\n// this works for CJS and ESM builds, but not for UMD\r\n\r\n// UMD exports the default export as a named and I don't want that\r\n// by design so I have to use `output.exports: \"default\"`, but\r\n// rollup complains of the 2 export types. So instead this\r\n// file is used to combined all the exports into a single default export\r\n// compatible for browser consumption\r\n\r\ndeclare module \"./lib/urbex\" {\r\n    interface ExtendedUrbexClient {\r\n        PipelineExecutor: typeof PipelineExecutor;\r\n        URLParser: typeof URLParser;\r\n        UrbexError: typeof UrbexError;\r\n        TimeoutError: typeof TimeoutError;\r\n        NetworkError: typeof NetworkError;\r\n        PipelineError: typeof PipelineError;\r\n    }\r\n}\r\n\r\nurbex.PipelineExecutor = PipelineExecutor;\r\nurbex.URLParser = URLParser;\r\nurbex.UrbexError = UrbexError;\r\nurbex.TimeoutError = TimeoutError;\r\nurbex.NetworkError = NetworkError;\r\nurbex.PipelineError = PipelineError;\r\n\r\nexport default urbex;\r\n"],"names":["hasOwnProperty","obj","prop","call","isUndefined","value","isArray","Array","isObject","isString","isFunction","isNumber","isEmpty","length","Object","keys","uppercase","String","toUpperCase","lowercase","toLowerCase","clone","slice","assign","deepClone","map","constructor","key","merge","defaultOptions","options","strict","filteredOptions","reduce","acc","deepMerge","_len","arguments","objects","_key","concat","forEach","fn","index","ensureLeadingToken","token","argumentIsNotProvided","startsWith","ensureTrailingToken","endsWith","combineStrings","delimiter","_len2","strings","_key2","filter","string","join","createEmptyScheme","split","object","nestedKeys","nestedObject","REQUEST_BODY_METHODS","URL_COMPONENT_KEYS","DEFAULT_PIPELINE_EXECUTORS","request","response","DEFAULT_CLIENT_OPTIONS","url","timeout","method","headers","data","cache","pipelines","maxContentLength","Infinity","responseType","responseEncoding","resolveStatus","config","status","DEFAULT_URBEX_RESPONSE","METHODS","PARSE_URL","IPV4_REGEX","IPV6_REGEX","AUTH_REGEX","removeEncodedWhitespace","input","replace","formatPort","port","mergeAuth","username","password","Error","buildProtocol","protocol","hasHostname","extractScheme","convertSearchParamsToString","search","searchParams","URLSearchParams","entry","append","toString","BaseURLParser","TypeError","this","$component","parse","href","serialize","sync","syncType","origin","syncAuth","host","authString","match","exec","parseProtocol","parseAuth","auth","parseHostname","test","matches","numbers","num","parseInt","every","normalizeIPv4","normalizeIPv6","hostname","parsePort","isNaN","parseOrigin","includes","replaceAuth","parsePathname","pathname","parseParams","params","parseHash","hash","overwrite","component","trim","query","_component","tokens","_","push","newOrigin","error","URLParser","super","static","set","existing","incoming","originWithPort","originwithPathname","originwithHash","setSearchParams","originwithSearch","toJSON","environment","_context","detectContext","window","document","process","versions","node","nodeStrictCheck","isBrowser","isNode","context","isDevelopment","env","NODE_ENV","isProduction","getEnvironmentComponent","location","PORT","_typeof","Symbol","iterator","prototype","_defineProperties","target","props","i","descriptor","enumerable","configurable","writable","defineProperty","_defineProperty","_arrayLikeToArray","arr","len","arr2","isPureObject","isNegative","absolute","Math","abs","shallowMerge","source","_Symbol$iterator","colors","red","yellow","green","lightblue","debug","message","color","DEBUG","colorizedMessage","console","log","timeProvider","Date","DEFAULT_CLOCK_OPTIONS","maxItems","ttl","interval","autoStart","resetTimeoutOnAccess","parseCacheOptions","undefined","opts","onExpire","createEntityKey","isHashed","JSON","stringify","a","b","charCodeAt","DEFAULT_STATISTCS","hits","sets","misses","evictions","expired","deletes","overwrites","clears","lifecycles","CacheClock","instance","Constructor","_classCallCheck","$birth","now","$cache","Map","configure","$statistics","start","protoProps","staticProps","stop","_step","_iterator","o","allowArrayLike","it","minLen","n","name","from","_unsupportedIterableToArray","F","s","done","e","f","err","normalCompletion","didErr","step","next","return","_createForOfIteratorHelper","_entry","del","k","get","size","$options","$clock","callback","delay","prune","bind","global","setTimeout","clearTimeout","hashedKey","_parseCacheOptions","clockItem","v","t","existingEntry","item","clear","values","UrbexError","create","stack","isInstance","TimeoutError","NetworkError","PipelineError","resolveRequest","resolve","reject","entity","statusCode","errorInstance","createErrorInstance","statusMessage","statusText","createFromError","NodeRequest","getAgentFromProtocol","https","http","handleDataProtocolRequest","Promise","async","_resolve","_reject","_config$data","agent","has","path","onData","onError","onClose","complete","aborted","destroyed","destroy","onEnd","Buffer","on","chunks","chunk","timeoutError","end","DECODERS","br","zlib","brotliDecompress","util","promisify","gzip","gunzip","deflate","inflate","compress","createUnzip","BROWSER_RESPONSE_TYPES","BrowserRequest","send","XMLHttpRequest","manageListeners","listeners","event","listener","open","delete","setRequestHeader","ev","abortError","networkError","responseXML","responseText","getAllResponseHeaders","onreadystatechange","PipelineExecutor","executor","$executor","pipeline","pipelineResult","execute","DEFAULT_BROWSER_HEADERS","DEFAULT_NODE_HEADERS","version","platform","removeNewLines","stringReplacer","parseHeaderKey","format","word","parsedWord","charAt","formatHeaderKey","parseHeaderValue","UrbexHeaders","withDefaults","defaults","parsedHeaders","pair","pairKey","pairValue","forceMerge","normalizedHeaders","normalize","merged","$headers","headerKey","empty","newHeaders","normalizedKey","normalizedValue","normalizeHeaders","RequestApi","register","$api","configuration","concludeRequest","startTime","timestamp","toISOString","clonedResponse","result","incomingResult","hit","duration","startRequest","isCacheEnabled","enabled","cacheKey","getCacheKey","pulled","stored","internalError","SKIPPABLE_RESPONSE_TYPES","transformRequestData","decodeResponseData","encoding","isBuffer","decoder","decompressed","transformResponseData","returnValueOnError","safeJSONParse","manageURLComponent","allowEndpoints","RequestConfig","setup","createConfigurationObject","envComponent","unshift","defaultConfig","parsed","parseIncomingConfig","_configuration$timeou","_configuration$maxCon","currentConfig","clonedUrl","parser","construct","$config","_config$headers$get","_config$headers","_config$url$toJSON","_config$url","incomingHeaders","incomingComponent","mergedHeaders","mergedComponent","headersObject","componentObject","reset","createMethodConfig","uri","UrbexClient","stopCache","isRunning","dispatchRequest","injectPipeline","ejectPipeline","subscribe","unsubscribe","isUrbexClient","client","urbex","extendedClient","isolateClient","Client","createClient"],"mappings":"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"}