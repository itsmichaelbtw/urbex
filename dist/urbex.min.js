/**
    * https://github.com/orison-networks/urbex#readme
    * (c) 2022 Orison Networks
    * @license MIT
    */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('http'), require('https'), require('zlib'), require('util')) :
    typeof define === 'function' && define.amd ? define(['http', 'https', 'zlib', 'util'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.urbex = factory(global.http, global.https, global.zlib, global.util));
})(this, (function (http, https, zlib, util) { 'use strict';

    class Environment {
      constructor() {
        this._context = this.detectContext();
      }
      detectContext() {
        if (typeof window !== "undefined" && typeof window.document !== "undefined") {
          return "browser";
        }
        if (typeof process !== "undefined" && process.versions && process.versions.node) {
          return "node";
        }
        throw new Error("Unable to detect environment context.");
      }
      nodeStrictCheck() {
        if (this.isBrowser) {
          throw new Error("This method is not available in the browser environment.");
        }
      }
      get process() {
        if (this.isNode) {
          return process;
        }
        return {};
      }
      get context() {
        return this._context;
      }
      get isBrowser() {
        return this.context === "browser";
      }
      get isNode() {
        return this.context === "node";
      }
      get isDevelopment() {
        this.nodeStrictCheck();
        return process.env.NODE_ENV === "development";
      }
      get isProduction() {
        this.nodeStrictCheck();
        return process.env.NODE_ENV === "production";
      }
    }
    const environment$1 = new Environment();

    function _defineProperty$1(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }

    /**
        * https://github.com/itsmichaelbtw/cache-clock#readme
        * (c) 2022 Michael Cizek
        * @license MIT
        */

    function _typeof(obj) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelper(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it) o = it;
          var i = 0;
          var F = function () {};
          return {
            s: F,
            n: function () {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            },
            e: function (e) {
              throw e;
            },
            f: F
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var normalCompletion = true,
        didErr = false,
        err;
      return {
        s: function () {
          it = it.call(o);
        },
        n: function () {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        },
        e: function (e) {
          didErr = true;
          err = e;
        },
        f: function () {
          try {
            if (!normalCompletion && it.return != null) it.return();
          } finally {
            if (didErr) throw err;
          }
        }
      };
    }

    function isUndefined$1(value) {
      return typeof value === "undefined";
    }
    function isPureObject(value) {
      return _typeof(value) === "object" && value !== null && !Array.isArray(value);
    }
    function isNumber(value) {
      return typeof value === "number" && !isNaN(value);
    }
    function isFunction$1(value) {
      return typeof value === "function";
    }
    function isString$1(value) {
      return typeof value === "string";
    }
    function isNegative(value) {
      return value < 0;
    }
    function absolute(value) {
      return Math.abs(value);
    }
    function shallowMerge(target, source) {
      return Object.assign({}, target, source);
    }
    function stringify(value) {
      if (isUndefined$1(value)) {
        return "";
      }
      if (isString$1(value)) {
        return value;
      }
      return JSON.stringify(value);
    }

    function getCurrentEnvironment() {
      if (typeof window !== "undefined" && typeof window.document !== "undefined") {
        return "browser";
      }
      if (typeof process !== "undefined" && process.versions && process.versions.node) {
        return "node";
      }
      return "unknown";
    }
    var environment = getCurrentEnvironment();

    var colors = {
      red: "\x1b[31m",
      yellow: "\x1b[33m",
      green: "\x1b[32m",
      lightblue: "\x1b[36m"
    };
    var globals = {
      reset: "\x1b[0m",
      bright: "\x1b[1m"
    };
    function debug$1(message, color) {
      if (debug$1.DEBUG) {
        var prefix = "[CACHE-CLOCK] ";
        var colorizedMessage = "".concat(colors[color]).concat(prefix).concat(message).concat(globals.reset);
        console.log(colorizedMessage);
      }
    }
    debug$1.DEBUG = false;

    function hash(input) {
      if (typeof input !== "string") {
        input = JSON.stringify(input);
      }
      var numberHash = input.split("").reduce(function (a, b) {
        a = (a << 5) - a + a * 24 + b.charCodeAt(0);
        a |= 0;
        return a;
      }, 0);
      return numberHash.toString(32);
    }

    function getBestTimeProvider() {
      try {
        // future: use either perf_hooks for node js or performance for browser
        // fallback on Date.now() for now
        return Date;
      } catch (error) {
        return Date;
      }
    }
    var timeProvider = getBestTimeProvider();

    var _Symbol$iterator;
    var DEFAULT_CLOCK_OPTIONS = {
      maxItems: 1000,
      ttl: Infinity,
      interval: 15 * 1000,
      debug: false,
      autoStart: true
    };
    function invokeTimeout(callback, delay) {
      var timeout = environment === "node" ? global.setTimeout : window.setTimeout;
      return timeout.call(null, callback, delay);
    }
    function parseCacheOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultOptions = arguments.length > 1 ? arguments[1] : undefined;
      if (!isPureObject(options)) {
        debug$1("Invalid options passed to cache clock, using defaults.", "yellow");
        return defaultOptions;
      }
      var opts = shallowMerge(defaultOptions, options);
      if (isNumber(opts.maxItems) && isNegative(opts.maxItems)) {
        opts.maxItems = absolute(opts.maxItems);
      } else if (!isNumber(opts.maxItems)) {
        opts.maxItems = defaultOptions.maxItems;
      }
      if (isNumber(opts.ttl) && isNegative(opts.ttl)) {
        opts.ttl = absolute(opts.ttl);
      } else if (!isNumber(opts.maxItems)) {
        opts.ttl = defaultOptions.ttl;
      }
      if (isNumber(opts.interval) && isNegative(opts.interval)) {
        opts.interval = absolute(opts.interval);
      } else if (!isNumber(opts.interval)) {
        opts.interval = defaultOptions.interval;
      }
      if (opts.onExpire && !isFunction$1(opts.onExpire)) {
        opts.onExpire = undefined;
      }
      if (opts.maxItems === 0) {
        opts.maxItems = 1;
      }
      return opts;
    }
    function createEntityKey(key, isHashed) {
      if (isHashed) {
        return key;
      }
      return hash(stringify(key));
    }
    _Symbol$iterator = Symbol.iterator;
    var CacheClock = /*#__PURE__*/function () {
      /**
       * Create a new instance of the cache clock. You can
       * pass a configuration object to set the default
       * options for all cacheable items.
       *
       * ```js
       * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });
       * ```
       */
      function CacheClock(options) {
        _classCallCheck(this, CacheClock);
        _defineProperty(this, "$birth", void 0);
        _defineProperty(this, "$cache", void 0);
        _defineProperty(this, "$clock", void 0);
        _defineProperty(this, "$options", void 0);
        this.$birth = timeProvider.now();
        this.$cache = new Map();
        this.configure(options);
        if (this.options.autoStart) {
          this.start();
        }
      }
      _createClass(CacheClock, [{
        key: "prune",
        value: function prune() {
          this.stop();
          var now = timeProvider.now();
          var _iterator = _createForOfIteratorHelper(this),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var value = _step.value;
              if (value.e <= now) {
                var _entry = this.del(value.k, true);
                if (this.options.onExpire && _entry) {
                  this.options.onExpire(_entry);
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          this.start();
        }

        /**
         * Create a new instance of the cache clock. You can
         * pass a configuration object to set the default
         * options for all cacheable items.
         *
         * ```js
         * const clock = new CacheClock({ ttl: 5 * 60 * 1000 });
         * ```
         */
      }, {
        key: "age",
        get:
        /**
         * The age of the cache clock in `ms`.
         */
        function get() {
          return timeProvider.now() - this.$birth;
        }

        /**
         * The number of items in the cache.
         */
      }, {
        key: "size",
        get: function get() {
          return this.$cache.size;
        }

        /**
         * Global configuration that applies to all cacheable items.
         */
      }, {
        key: "options",
        get: function get() {
          return this.$options;
        }

        /**
         * Whether the clock is currently running.
         */
      }, {
        key: "isRunning",
        get: function get() {
          return !!this.$clock;
        }

        /**
         * Configure the cache clock. Use this method to change the global configuration
         * that applies to all cacheable items.
         *
         * Items that have been cached prior to updating the configuration will not be
         * affected.
         *
         * ```js
         * const clock = new CacheClock();
         * clock.configure({ ttl: 5 * 60 * 1000 });
         * ```
         */
      }, {
        key: "configure",
        value: function configure() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          this.$options = parseCacheOptions(options, this.options || DEFAULT_CLOCK_OPTIONS);
          debug$1.DEBUG = this.options.debug;
          if (this.options.interval < DEFAULT_CLOCK_OPTIONS.interval) {
            debug$1("A cache clock interval less than 15 seconds is not recommended.", "yellow");
          }
        }

        /**
         * Start the cache clock. This is automatically called when the cache clock is created.
         * You should only need to call this method if you have stopped the cache clock manually.
         *
         * This will spawn a new clock with the full timeout interval. This does not resume the
         * clock from where it left off.
         */
      }, {
        key: "start",
        value: function start() {
          if (this.options.interval === Infinity || this.options.interval === 0) {
            debug$1("Disabling the clock due to an unsupported interval.", "yellow");
            return;
          }
          if (this.$clock) {
            debug$1("Cache clock is already running. Unable to start.", "red");
            return;
          }
          this.$clock = invokeTimeout(this.prune.bind(this), this.options.interval);
        }

        /**
         * Manually stop the cache clock. This will disable the automatic expiration of items. This does
         * not prevent items from being checked for expiration.
         */
      }, {
        key: "stop",
        value: function stop() {
          if (!this.$clock) {
            debug$1("Cache clock is not running. Unable to stop.", "red");
            return;
          }
          clearTimeout(this.$clock);
          this.$clock = null;
        }

        /**
         * Add an item to the cache. Optionally, you can specify a time to live for the item.
         *
         * If the cache is full, the oldest item will be removed.
         */
      }, {
        key: "set",
        value: function set(key, value, options) {
          var hashedKey = createEntityKey(key, false);
          var _parseCacheOptions = parseCacheOptions(options, this.options),
            ttl = _parseCacheOptions.ttl;
          var clockItem = {
            k: hashedKey,
            v: value,
            t: ttl,
            e: timeProvider.now() + ttl
          };
          if (this.has(hashedKey, true)) {
            this.del(hashedKey);
          }
          if (this.size >= this.options.maxItems) {
            debug$1("The cache is full, removing oldest item.", "yellow");
            this.del(this.$cache.keys().next().value, true);
          }
          this.$cache.set(hashedKey, clockItem);
          return this;
        }

        /**
         * Retrieve an item from the cache. This returns the internal
         * `CacheEntry` used to store the value.
         */
      }, {
        key: "get",
        value: function get(key) {
          var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var hashedKey = createEntityKey(key, isHashed);
          var item = this.$cache.get(hashedKey);
          if (isUndefined$1(item)) {
            return undefined;
          }
          if (item.e < timeProvider.now()) {
            debug$1("Cache item ".concat(key, " has expired."), "red");
            this.del(key, true);
            return undefined;
          }
          return item;
        }

        /**
         * Deletes an item from the cache. Returns the deleted item
         * if it exists.
         */
      }, {
        key: "del",
        value: function del(key) {
          var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var hashedKey = createEntityKey(key, isHashed);
          var item = this.$cache.get(hashedKey);
          if (isUndefined$1(item)) {
            return undefined;
          }
          debug$1("Deleting cache item ".concat(key, "."), "green");
          this.$cache["delete"](hashedKey);
          return item;
        }

        /**
         * Returns a boolean indicating whether the cache contains an item.
         */
      }, {
        key: "has",
        value: function has(key) {
          var isHashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var hashedKey = createEntityKey(key, isHashed);
          return this.$cache.has(hashedKey);
        }

        /**
         * Wipe the cache clean.
         */
      }, {
        key: "clear",
        value: function clear() {
          this.$cache.clear();
        }

        /**
         * Create a cache key based on the input.
         */
      }, {
        key: "getCacheKey",
        value: function getCacheKey(input) {
          return createEntityKey(input, false);
        }
      }, {
        key: _Symbol$iterator,
        value: function value() {
          return this.$cache.values();
        }
      }], [{
        key: "create",
        value: function create() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return new CacheClock(options);
        }
      }]);
      return CacheClock;
    }();

    /**
     * Check the Object.prototype.toString.call() of a value. Strips the [object ] part.
     */
    function hasOwnProperty(obj, prop) {
      return obj.hasOwnProperty.call(obj, prop);
    }
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isObject(value) {
      return typeof value === "object" && value !== null && !isArray(value);
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isEmpty(value) {
      if (isArray(value)) {
        return value.length === 0;
      } else if (isObject(value)) {
        return Object.keys(value).length === 0;
      } else {
        return !value;
      }
    }
    function capitalize(value) {
      value = String(value);
      return value.charAt(0).toUpperCase() + value.slice(1);
    }
    function uppercase(value) {
      return String(value).toUpperCase();
    }
    function clone(value) {
      if (isArray(value)) {
        return value.slice();
      } else if (isObject(value)) {
        return Object.assign({}, value);
      } else {
        return value;
      }
    }
    function merge(defaultOptions, options) {
      return Object.assign({}, defaultOptions, options);
    }
    function deepMerge() {
      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }
      return objects.reduce((acc, obj) => {
        if (isArray(obj)) {
          return acc.concat(obj);
        }
        for (const key in obj) {
          if (isArray(acc[key]) && isArray(obj[key])) {
            acc[key] = acc[key].concat(obj[key]);
          } else if (isObject(acc[key]) && isObject(obj[key])) {
            acc[key] = deepMerge(acc[key], obj[key]);
          } else {
            acc[key] = obj[key];
          }
        }
        return acc;
      }, {});
    }
    function forEach(obj, fn) {
      if (isUndefined(obj)) {
        return;
      }
      if (isArray(obj)) {
        obj.forEach(function (value, index) {
          fn.call(null, index, value, obj);
        });
      } else {
        for (const key in obj) {
          fn.call(null, key, obj[key], obj);
        }
      }
    }
    function extractMatchFromRegExp(value, regexp) {
      let group = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      let defaultValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      if (value) {
        const matches = regexp.exec(value);
        if (isArray(matches) && !isEmpty(matches)) {
          return matches[group];
        }
      }
      return defaultValue;
    }
    function stringReplacer(value, search, replace) {
      return value.replace(search, replace);
    }
    function ensureLeadingToken(token, value) {
      if (argumentIsNotProvided(value)) {
        return "";
      }
      if (value.startsWith(token)) {
        return value;
      }
      return `${token}${value}`;
    }
    function ensureTrailingToken(token, value) {
      if (argumentIsNotProvided(value)) {
        return "";
      }
      if (value.endsWith(token)) {
        return value;
      }
      return `${value}${token}`;
    }
    function argumentIsNotProvided(value) {
      return value === undefined || value === null;
    }
    function combineStrings() {
      let delimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      for (var _len2 = arguments.length, strings = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        strings[_key2 - 1] = arguments[_key2];
      }
      return strings.filter(string => !isEmpty(string)).join(delimiter);
    }
    function createEmptyScheme(keys) {
      return keys.reduce((acc, key) => {
        const keys = key.split(".");
        if (keys.length === 1) {
          acc[key] = null;
        } else {
          const [object, ...nestedKeys] = keys;
          if (!acc[object]) {
            acc[object] = {};
          }
          const nestedObject = createEmptyScheme(nestedKeys);
          acc[object] = merge(acc[object], nestedObject);
        }
        return acc;
      }, {});
    }

    class UrbexError extends Error {
      constructor(error) {
        if (!(error instanceof Error)) {
          error = new Error(error);
        }
        super(error.message);
        this.name = error.name;
        this.stack = error.stack;
      }
      static create(error, config, response) {
        const urbexError = new UrbexError(error);
        urbexError.config = config;
        urbexError.response = response;
        urbexError.status = response.status;
        urbexError.request = config;
        return urbexError;
      }
    }
    class TimeoutError extends UrbexError {
      constructor(timeout) {
        const error = new Error(`Request timed out after ${timeout}ms.`);
        super(error);
      }
    }

    class NodeRequest {
      getAgentFromProtocol(protocol) {
        if (protocol === "https") {
          return https;
        }
        return http;
      }
      handleDataProtocolRequest(config) {
        return new Promise((resolve, reject) => {
          resolve({
            data: null,
            request: null,
            response: null
          });
        });
      }
      async send(config) {
        return new Promise((resolve, reject) => {
          var _config$data;
          const agent = this.getAgentFromProtocol(config.url.protocol);
          if (config.url.protocol === "data") {
            return this.handleDataProtocolRequest(config);
          }
          if (!config.headers.has("Accept-Encoding")) {
            config.headers.set({
              "Accept-Encoding": "gzip, deflate, br"
            });
          }
          if (config.url.params && !isString(config.url.params)) {
            config.url.params = config.url.params.toString();
          } else {
            config.url.params = "";
          }
          function onError(error) {
            const err = new UrbexError(error);
            err.config = config;
            err.request = request;
            return reject(err);
          }
          const options = {
            protocol: ensureTrailingToken(":", config.url.protocol),
            href: config.url.href,
            hostname: config.url.hostname,
            path: combineStrings("", config.url.endpoint, config.url.params),
            headers: config.headers.get(),
            timeout: config.timeout
          };
          if (config.url.port) {
            const port = parseInt(config.url.port.toString());
            if (!isNaN(port)) {
              options.port = port;
            }
          }
          const request = agent.request(options);
          request.on("response", response => {
            if (response.destroyed || request.destroyed) {
              return onError(new UrbexError("Request was destroyed."));
            }
            if (config.responseType === "stream") {
              return resolve({
                data: response,
                request: request,
                response: response
              });
            }
            const chunks = [];
            response.on("data", chunks.push.bind(chunks));
            response.on("error", onError);
            response.on("close", () => {
              if (response.complete) {
                return;
              }
              response.destroy();
              request.destroy();
              return onError(new UrbexError("Request was closed prematurely."));
            });
            response.on("end", () => {
              const body = Buffer.concat(chunks);
              resolve({
                data: body,
                request: request,
                response: response
              });
            });
          });
          if (config.timeout) {
            request.setTimeout(config.timeout, () => {
              reject(new TimeoutError(config.timeout));
            });
          }
          request.on("error", onError);
          request.end((_config$data = config.data) !== null && _config$data !== void 0 ? _config$data : undefined);
        });
      }
    }
    const br = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.brotliDecompress) ? util.promisify(zlib.brotliDecompress) : null;
    const gzip = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.gunzip) ? util.promisify(zlib.gunzip) : null;
    const deflate = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.inflate) ? util.promisify(zlib.inflate) : null;
    const compress = isFunction(zlib === null || zlib === void 0 ? void 0 : zlib.createUnzip) ? util.promisify(zlib.createUnzip) : null;
    const DECODERS = {
      br,
      gzip,
      deflate,
      compress
    };

    class BrowserRequest {
      send(config) {
        return new Promise(() => {});
      }
    }
    createEmptyScheme(["br", "gzip", "deflate", "compress"]);

    const DEFAULT_BROWSER_HEADERS = {
      "Content-Type": "application/json"
    };
    const DEFAULT_NODE_HEADERS = merge(DEFAULT_BROWSER_HEADERS, {
      "User-Agent": `UrbexClient (Node.js ${environment$1.process.version}; ${environment$1.process.platform})`
    });
    const DEFAULT_URI_COMPONENT = createEmptyScheme(["endpoint", "hostname", "href", "origin", "params", "port", "protocol", "urlMount"]);
    const DEFAULT_PIPELINE_EXECUTORS = {
      request: [],
      response: []
    };
    const DEFAULT_CLIENT_OPTIONS = {
      url: merge(DEFAULT_URI_COMPONENT, {
        protocol: "http",
        urlMount: "/api"
      }),
      timeout: 0,
      method: "GET",
      headers: null,
      data: null,
      cache: {},
      pipelines: DEFAULT_PIPELINE_EXECUTORS,
      maxContentLength: Infinity,
      responseType: "json",
      responseEncoding: "utf8"
    };
    const DEFAULT_URBEX_RESPONSE = createEmptyScheme(["status", "statusText", "headers", "data", "config", "request", "response", "duration", "timestamp", "cache.key", "cache.hit", "cache.pulled", "cache.stored"]);

    async function startRequest(config) {
      const startTime = Date.now();
      const timestamp = new Date().toISOString();
      const clonedResponse = clone(DEFAULT_URBEX_RESPONSE);
      if (!isEmpty(config.pipelines.request)) {
        // loop over the request pipelines
        // each pipeline is a Promise that returns a new config
        // each new config is passed to the next pipeline
        // the very last config will mutate the `config` parameter

        for (const pipeline of config.pipelines.request) {
          config = await pipeline.execute(config);
          if (config === null) {
            throw new Error("Urbex expected a valid configuration to be returned from a request pipeline, but got null.");
          }
        }
      }

      // all of the request pipelines are executed here

      return async function concludeRequest(result) {
        const incomingResult = result;

        // all of the response pipelines are executed here

        let response = deepMerge(clonedResponse, {
          data: incomingResult.data,
          config: config,
          request: incomingResult.request,
          response: incomingResult.response,
          timestamp: timestamp,
          responseType: config.responseType
        });
        if (incomingResult.response) {
          response.headers = incomingResult.response.headers;
          response.status = incomingResult.response.statusCode;
          response.statusText = incomingResult.response.statusMessage;
        }
        if (!isEmpty(config.pipelines.response)) {
          for (const pipeline of config.pipelines.response) {
            response = await pipeline.execute(response);
          }
        }
        const endTime = Date.now();
        const duration = endTime - startTime;
        response.duration = duration;
        return Promise.resolve(response);
      };
    }

    // here all of the interceptors are checked
    // cache clocks are checked here
    // the response is created here

    class RequestApi {
      /**
       * The internal api that is used to send requests.
       */

      /**
       * An isolated cache module that is used to cache requests.
       */

      constructor() {
        this.register(environment$1.context);
        this.$cache = new CacheClock({
          autoStart: false,
          debug: false
        });
      }
      register(context) {
        if (context === "browser") {
          this.$api = new BrowserRequest();
          return;
        }
        if (context === "node") {
          this.$api = new NodeRequest();
          return;
        }
        throw new Error(`Urbex expected a valid context to register a request api, but got ${context}.`);
      }
      async dispatchRequest(config) {
        try {
          const configuration = clone(config);
          const concludeRequest = await startRequest(configuration);
          const isCacheEnabled = configuration.cache && configuration.cache.enabled;

          // for some odd reason, result.cache had this weird mutation
          // issue even when CLONING the result, so I had to do this
          // to get it to work properly

          const cache = {
            key: null,
            hit: false,
            pulled: false,
            stored: false
          };
          if (isCacheEnabled) {
            const cacheKey = this.$cache.getCacheKey(configuration.url.href);
            const entity = this.$cache.get(cacheKey, true);
            cache.hit = true;
            if (entity) {
              const result = await concludeRequest({
                data: entity.v
              });
              cache.key = cacheKey;
              cache.pulled = true;
              result.cache = cache;
              return Promise.resolve(result);
            }
          }
          const response = await this.$api.send(configuration);
          const result = await concludeRequest(response);
          if (isCacheEnabled) {
            this.$cache.set(configuration.url.href, response.data);
            cache.key = this.$cache.getCacheKey(configuration.url.href);
            cache.stored = true;
          }
          result.cache = cache;
          return Promise.resolve(result);
        } catch (error) {
          return Promise.reject(new UrbexError(error));
        }
      }
    }

    function debug(type, message) {
      console[type](`[urbex] ${message}`);
    }

    function parseHeaderKey(key) {
      if (key) {
        return formatHeaderKey(key.toLowerCase()).trim();
      }
      return undefined;
    }
    function parseHeaderValue(value) {
      if (isUndefined(value) || value === false || value === null) {
        return undefined;
      }
      if (isArray(value)) {
        return value.join(", ");
      }
      if (isObject(value)) {
        return JSON.stringify(value);
      }
      return String(value);
    }
    function normalizeHeaders(headers) {
      const newHeaders = {};
      forEach(headers, (key, value) => {
        if (isUndefined(key) || isUndefined(value)) {
          return;
        }
        const normalizedKey = parseHeaderKey(key);
        const normalizedValue = parseHeaderValue(value);
        if (normalizedKey && normalizedValue) {
          newHeaders[normalizedKey] = normalizedValue;
        }
      });
      return newHeaders;
    }
    function formatHeaderKey(key) {
      return key.split("-").map(capitalize).join("-");
    }
    class UrbexHeaders {
      constructor(headers) {
        let withDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        _defineProperty$1(this, "$headers", {});
        if (withDefaults) {
          this.set(this.defaults, false);
        }
        if (isObject(headers) && !isEmpty(headers)) {
          this.set(headers, withDefaults);
        }
      }
      static construct() {
        let headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        let withDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        return new UrbexHeaders(headers, withDefaults);
      }
      get defaults() {
        return environment$1.isNode ? DEFAULT_NODE_HEADERS : DEFAULT_BROWSER_HEADERS;
      }

      /**
       * Set a header configuration to use for all requests made by the current
       * instance of the Urbex client
       *
       * Setting a configuration will merge with any existing configuration.
       * Optionally, you can pass a boolean to clear the existing configuration
       *
       * @param headers The headers to set
       * @param forceMerge Whether to merge the headers with the existing configuration
       */
      set(headers) {
        let forceMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!isObject(headers)) {
          debug("error", `Attempted to set headers with a non-object value: ${typeof headers}`);
          return headers;
        }
        const normalizedHeaders = this.normalize(headers);
        const merged = forceMerge ? merge(this.$headers, normalizedHeaders) : normalizedHeaders;
        return this.$headers = merged;
      }
      /**
       * Get the current headers object
       */
      get() {
        return this.$headers;
      }

      /**
       * Whether the headers object contains a given header
       */
      has(key) {
        return hasOwnProperty(this.$headers, key);
      }

      /**
       * Delete a header from the headers object
       */
      delete(key) {
        forEach(this.$headers, headerKey => {
          if (headerKey.toLowerCase() === key.toLowerCase()) {
            delete this.$headers[headerKey];
          }
        });
      }
      /**
       *
       * Clear all headers that have been set
       * @param empty Whether to empty the headers object
       *
       */
      clear() {
        let empty = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        this.$headers = {};
        if (!empty) {
          this.set(this.defaults, false);
        }
      }

      /**
       * Normalize an incoming headers object
       */

      normalize(headers) {
        if (argumentIsNotProvided(headers) || !isObject(headers)) {
          return {};
        }
        return normalizeHeaders(headers);
      }
    }

    class PipelineExecutor {
      constructor(executor) {
        _defineProperty$1(this, "$executor", null);
        this.$executor = executor;
      }
      execute(config) {
        return this.$executor(config);
      }
    }

    const transformRequestData = new PipelineExecutor(config => {
      return Promise.resolve(config);
    });
    const decodeResponseData = new PipelineExecutor(async response => {
      const responseType = response.config.responseType;
      if (responseType === "raw" || responseType === "stream") {
        return Promise.resolve(response);
      }
      const encoding = response.headers["content-encoding"];
      if (Buffer.isBuffer(response.data) && response.data.length) {
        if (encoding) {
          const decoder = DECODERS[encoding];
          if (decoder) {
            const decompressed = await decoder(response.data);
            const maxContentLength = response.config.maxContentLength;
            if (maxContentLength > -1 || maxContentLength !== Infinity) {
              if (decompressed.length > maxContentLength) {
                throw new Error(`Content length of ${decompressed.length} exceeds the maxContentLength of ${maxContentLength}`);
              }
            }
            response.data = decompressed;
          }
        }
      } else {
        response.data = null;
      }
      return Promise.resolve(response);
    });
    const transformResponseData = new PipelineExecutor(response => {
      const responseType = response.config.responseType;
      if (responseType === "raw" || responseType === "arraybuffer" || responseType === "stream") {
        return Promise.resolve(response);
      }
      if (response.data) {
        // https://stackoverflow.com/questions/24356713/node-js-readfile-error-with-utf8-encoded-file-on-windows

        const {
          responseEncoding,
          responseType
        } = response.config;
        const bufferString = response.data.toString(responseEncoding);
        if (responseType === "json") {
          response.data = JSON.parse(bufferString);
        } else {
          response.data = bufferString;
        }
      }
      return Promise.resolve(response);
    });

    // support for any protocols to be used with the uri component
    // currently only http and https are supported

    // regex to get the protocol from the uri component, can match anything
    const PROTOCOL_REGEXP = /^([a-z0-9]+):\/\//i;
    const URI_TEMPLATE_REGEXP_LEFT = "[{][^{{]*\\b";
    const URI_TEMPLATE_REGEXP_RIGHT = "\\b[^{}]*[}]";
    const METHODS = ["PUT", "POST", "PATCH", "OPTIONS", "HEAD", "GET", "DELETE"];

    /**
     * Test if a url is valid
     */
    function isValidURL(url) {
      try {
        new URL(url);
        return true;
      } catch (error) {
        return false;
      }
    }
    function convertStringToURIComponent(input) {
      let urlMount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      const url = new URL(input);
      const protocol = stringReplacer(url.protocol, ":", "");
      const port = url.port ? parseInt(url.port) : "";
      const pathname = stringReplacer(url.pathname, urlMount, "");
      return {
        href: url.href,
        origin: url.origin,
        protocol: protocol,
        hostname: url.hostname,
        port: port,
        endpoint: pathname,
        params: url.search,
        urlMount: urlMount
      };
    }

    // turn this into its own package
    function convertURIComponentToString(input) {
      let template = "{protocol+://}{hostname}{:+port}{urlMount}{endpoint}{?+params}";
      function createRegexString(word) {
        return new RegExp(`${URI_TEMPLATE_REGEXP_LEFT}${word}${URI_TEMPLATE_REGEXP_RIGHT}`, "gi");
      }
      if (argumentIsNotProvided(input) || isEmpty(input) || !isObject(input)) {
        return "";
      }
      if (input.params) {
        input.params = serializeParams(input.params);
      }
      forEach(input, (key, value) => {
        const regex = createRegexString(key);
        if (argumentIsNotProvided(value) || isEmpty(value)) {
          template = stringReplacer(template, regex, "");
        } else {
          const match = extractMatchFromRegExp(template, regex, 0, "");
          const templateValue = stringReplacer(match, key, value.toString()).replace(/\+/g, "").replace(/^\{/, "").replace(/\}$/, "");
          template = stringReplacer(template, match, templateValue);
        }
      });
      return template;
    }
    function parseURIIntoComponent(component) {
      let allowEndpoints = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (isString(component)) {
        if (isValidURL(component)) {
          return convertStringToURIComponent(component);
        } else if (allowEndpoints) {
          return {
            endpoint: ensureLeadingToken("/", component)
          };
        } else {
          throw new Error("An invalid URL was provided. A valid URL string in the format of <scheme>://<hostname> must be passed when using `urbex.configure()`.");
        }
      } else if (isObject(component)) {
        const protocol = extractMatchFromRegExp(component.protocol, PROTOCOL_REGEXP, 0, "http");
        const hostname = stringReplacer(component.hostname, new RegExp(`^${protocol}://`, "gi"), "");
        const endpoint = ensureLeadingToken("/", component.endpoint);
        const urlMount = ensureLeadingToken("/", component.urlMount);
        const buildableComponent = merge(component, {
          protocol: protocol,
          hostname: hostname,
          endpoint: endpoint,
          urlMount: urlMount
        });
        const componentAsString = convertURIComponentToString(buildableComponent);
        const newComponent = convertStringToURIComponent(componentAsString, urlMount);
        return newComponent;
      } else {
        throw new Error("Unable to parse the provided URI. Must be either a string or an object.");
      }
    }
    function serializeParams(params) {
      let serializerType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "string";
      if (argumentIsNotProvided(params)) {
        return null;
      }
      try {
        const searchParams = new URLSearchParams(params);
        if (serializerType === "object") {
          const params = {};
          searchParams.forEach((value, key) => {
            params[key] = value;
          });
          return params;
        }
        return searchParams.toString();
      } catch (error) {
        return null;
      }
    }

    function determineAppropriateURI() {
      const component = merge(DEFAULT_URI_COMPONENT, {
        protocol: "https",
        urlMount: "/api"
      });
      if (environment$1.isBrowser) {
        const {
          protocol,
          hostname,
          port
        } = window.location;
        Object.assign(component, {
          protocol: protocol.replace(":", ""),
          hostname: hostname,
          port: port
        });
      } else if (environment$1.isNode) {
        Object.assign(component, {
          protocol: "http",
          hostname: "localhost",
          port: 3000
        });
      }
      return component;
    }
    class RequestConfig {
      constructor(config) {
        const component = parseURIIntoComponent(determineAppropriateURI());
        this.$config = merge(DEFAULT_CLIENT_OPTIONS, {
          url: component,
          headers: new UrbexHeaders()
        });
        if (isObject(config) && !isEmpty(config)) {
          this.set(this.createConfigurationObject(config, true));
        }
        this.$config.pipelines.request.unshift(transformRequestData);
        if (environment$1.isNode) {
          this.$config.pipelines.response.unshift(decodeResponseData, transformResponseData);
        }
      }
      defaultConfig() {
        return merge(DEFAULT_CLIENT_OPTIONS, {
          url: parseURIIntoComponent(determineAppropriateURI()),
          headers: new UrbexHeaders()
        });
      }
      createConfigurationObject(config, allowEndpoints) {
        const parsed = this.parseIncomingConfig(config, allowEndpoints);
        const merged = this.merge(parsed);
        return merged;
      }
      parseIncomingConfig(config, allowEndpoints) {
        var _configuration$timeou, _configuration$timeou2, _configuration$maxCon, _configuration$maxCon2;
        if (argumentIsNotProvided(config) || !isObject(config)) {
          throw new Error("The configuration must be an object with valid properties.");
        }
        const configuration = clone(config);
        if (hasOwnProperty(configuration, "url")) {
          const currentUrlConfig = this.get().url;
          if (isObject(configuration.url)) {
            // have to merge otherwise the uri parser may
            // throw an error if fewer values are provided
            configuration.url = merge(currentUrlConfig, configuration.url);
          }
          if (allowEndpoints && configuration.url.toString().startsWith("/")) {
            configuration.url = merge(currentUrlConfig, {
              endpoint: configuration.url
            });
          }
          const parsed = parseURIIntoComponent(configuration.url, allowEndpoints);
          configuration.url = parsed;
        }
        if (hasOwnProperty(configuration, "method")) {
          const method = uppercase(configuration.method);
          if (!METHODS.includes(method)) {
            throw new Error(`The method ${method} is not a valid HTTP method.`);
          }
          configuration.method = method;
        }
        const timeout = parseInt((_configuration$timeou = (_configuration$timeou2 = configuration.timeout) === null || _configuration$timeou2 === void 0 ? void 0 : _configuration$timeou2.toString()) !== null && _configuration$timeou !== void 0 ? _configuration$timeou : DEFAULT_CLIENT_OPTIONS.timeout.toString());
        if (isNaN(timeout)) {
          configuration.timeout = DEFAULT_CLIENT_OPTIONS.timeout;
        }
        const maxContentLength = parseInt((_configuration$maxCon = (_configuration$maxCon2 = configuration.maxContentLength) === null || _configuration$maxCon2 === void 0 ? void 0 : _configuration$maxCon2.toString()) !== null && _configuration$maxCon !== void 0 ? _configuration$maxCon : DEFAULT_CLIENT_OPTIONS.maxContentLength.toString());
        if (isNaN(maxContentLength)) {
          configuration.maxContentLength = DEFAULT_CLIENT_OPTIONS.maxContentLength;
        }
        const headers = UrbexHeaders.construct(configuration.headers, true);
        delete configuration.headers;
        return merge(configuration, {
          headers: headers
        });
      }
      set(config) {
        this.$config = config;
        return config;
      }
      merge(config) {
        var _config$headers$get, _config$headers;
        if (argumentIsNotProvided(config) || !isObject(config)) {
          return this.get();
        }
        const currentConfig = this.get();
        const incomingHeaders = (_config$headers$get = (_config$headers = config.headers) === null || _config$headers === void 0 ? void 0 : _config$headers.get()) !== null && _config$headers$get !== void 0 ? _config$headers$get : {};
        const mergedHeaders = merge(currentConfig.headers, incomingHeaders);
        delete config.headers;
        const merged = deepMerge(currentConfig, config);
        const headersObject = UrbexHeaders.construct(mergedHeaders);
        return merge(merged, {
          headers: headersObject
        });
      }
      get() {
        return this.$config;
      }

      /**
       * Reset the configuration to its default state.
       */
      reset() {}
    }

    function createMethodConfig(method, uri, config) {
      if (argumentIsNotProvided(uri)) {
        throw new Error("Attempted to call a HTTP method without providing a URL. If you want to use the default URL, use `urbex.send` instead.");
      }
      return merge(config, {
        url: uri,
        method: method
      });
    }
    class UrbexClient extends RequestApi {
      constructor(config) {
        super();
        _defineProperty$1(this, "$pipelines", {
          request: [],
          response: []
        });
        this.$config = new RequestConfig(config);
      }

      /**
       *
       * Creates a new instance of the UrbexClient.
       */
      static create(config) {
        return new UrbexClient(config);
      }

      /**
       * Current, and most up-to-date configuration of the UrbexClient.
       */
      get config() {
        return this.$config.get();
      }

      /**
       * The internal cache module.
       */
      get cache() {
        return this.$cache;
      }

      /**
       * Configures the UrbexClient. You are free to call this method as
       * many times as you want. All configurations will be merged together.
       *
       * @param config The configuration to use.
       */
      configure(config) {
        const configuration = this.$config.createConfigurationObject(config, false);
        this.$config.set(configuration);
        if (isEmpty(configuration.cache)) {
          if (this.$cache) {
            this.$cache.clear();
            if (this.$cache.isRunning) {
              this.$cache.stop();
            }
          }
        } else {
          this.$cache.configure(configuration.cache);
          if (!this.$cache.isRunning) {
            this.$cache.start();
          }
        }
      }
      send() {
        let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        const configuration = this.$config.parseIncomingConfig(config, true);
        const merged = this.$config.merge(configuration);
        return this.dispatchRequest(merged);
      }

      /**
       * Inject pipelines into the UrbexClient. This allows you to add custom logic to the request/response
       */
      injectPipeline() {}

      /**
       * Eject a pipeline from the UrbexClient.
       */
      ejectPipeline() {}

      /**
       * When a response is received, the UrbexClient will actively push out the response to all active
       * subscriptions
       */
      subscribe() {}
      unsubscribe() {}
    }
    forEach(["delete", "get", "head", "options"], (_, value) => {
      UrbexClient.prototype[value] = function (url, config) {
        return this.send(createMethodConfig(uppercase(value), url, config));
      };
    });
    forEach(["post", "put", "patch"], (_, value) => {
      UrbexClient.prototype[value] = function (url, data, config) {
        function combineIncomingConfig() {
          if (isUndefined(data)) {
            return data;
          }
          if (isObject(config)) {
            return merge(config, {
              data: data
            });
          } else {
            return {
              data
            };
          }
        }
        const configuration = combineIncomingConfig();
        return this.send(createMethodConfig(uppercase(value), url, configuration));
      };
    });
    function isUrbexClient(client) {
      return client instanceof UrbexClient;
    }

    function createClient() {
      const client = UrbexClient.create();
      const extendedClient = client;
      extendedClient.isolateClient = UrbexClient.create;
      extendedClient.environment = environment$1;
      extendedClient.isUrbexClient = isUrbexClient;
      extendedClient.Client = UrbexClient;
      return extendedClient;
    }
    const urbex = createClient();

    // since this package has a named export and a default export, rollup
    // uses `output.exports: "named"` to make the named export the default
    // this works for CJS and ESM builds, but not for UMD

    // UMD exports the default export as a named and I don't want that
    // by design so I have to use `output.exports: "default"`, but
    // rollup complains of the 2 export types. So instead this
    // file is used to combined all the exports into a single default export
    // compatible for browser consumption

    urbex.PipelineExecutor = PipelineExecutor;

    return urbex;

}));
//# sourceMappingURL=urbex.min.js.map
